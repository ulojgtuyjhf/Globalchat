
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Chat Gallery</title>
    
    <style>
    
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: #ffffff;
    color: #0f1419;
    transition: background-color 0.3s ease, color 0.3s ease;
}

.chat-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 0 60px 0;
    display: flex;
    flex-direction: column;
    height: calc(100vh - 60px);
    overflow-y: auto;
    scroll-behavior: smooth;
}

.message {
    display: flex;
    padding: 12px 16px;
    margin-bottom: 12px;
    align-items: flex-start;
    opacity: 0;
    transform: translateY(10px);
    animation: messageAppear 0.3s ease forwards;
    position: relative;
}

@keyframes messageAppear {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message:hover {
    background-color: rgba(0, 0, 0, 0.02);
    transition: background-color 0.2s ease;
}

.profile-pic {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
    flex-shrink: 0;
    object-fit: cover;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: transform 0.2s ease;
}

.message:hover .profile-pic {
    transform: scale(1.05);
}

.message-bubble {
    background-color: #f7f9fa;
    border-radius: 16px;
    padding: 14px;
    max-width: calc(100% - 60px);
    position: relative;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: box-shadow 0.2s ease, transform 0.2s ease;
}

@media (min-width: 768px) {
    .message-bubble {
        max-width: 60%;
    }
}

.message-header {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
}

.username {
    font-weight: 700;
    color: #0f1419;
    font-size: 15px;
    margin-right: 8px;
    transition: color 0.2s ease;
}

.status-indicator {
    width: 10px;
    height: 10px;
    margin-right: 6px;
    border-radius: 50%;
    background-color: #1da1f2;
    box-shadow: 0 0 0 rgba(29, 161, 242, 0.4);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(29, 161, 242, 0.4);
    }
    70% {
        box-shadow: 0 0 0 6px rgba(29, 161, 242, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(29, 161, 242, 0);
    }
}

.text-content {
    line-height: 1.4;
    margin-bottom: 8px;
}

.media-wrapper {
    width: 100%;
    max-width: 100%;
    margin: 10px 0;
    border-radius: 14px;
    overflow: hidden;
    background: #f7f9fa;
    position: relative;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: transform 0.3s ease;
}

.media-wrapper.media-loading::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 3px solid rgba(29, 161, 242, 0.1);
    border-top-color: #1da1f2;
    transform: translate(-50%, -50%);
    animation: spin 1s linear infinite;
}

.media-wrapper.media-loading {
    min-height: 200px;
}

.media-wrapper:hover {
    transform: scale(1.01);
}

.post-media {
    width: 100%;
    max-width: 100%;
    display: block;
    border-radius: 14px;
    transition: filter 0.3s ease;
}

.post-video {
    max-height: 80vh;
    background: #000;
}

.reactions-container {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.08);
}

.reaction {
    background: #ffffff;
    border-radius: 14px;
    padding: 2px 8px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 3px;
    cursor: pointer;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: all 0.2s ease;
}

.reaction:hover {
    background: #f0f3f5;
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.reaction.user-reacted {
    background: rgba(29, 161, 242, 0.1);
    color: #1da1f2;
    border-color: rgba(29, 161, 242, 0.2);
}

.reaction.user-reacted:hover {
    background: rgba(29, 161, 242, 0.15);
}

.loading-spinner {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 20px 0;
    height: 40px;
}

.spinner-inner {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid rgba(29, 161, 242, 0.1);
    border-top-color: #1da1f2;
    animation: spin 0.8s cubic-bezier(0.5, 0.1, 0.4, 0.9) infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

.emoji-picker {
    position: absolute;
    bottom: 100%;
    left: 0;
    background: #ffffff;
    border-radius: 16px;
    padding: 8px;
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 4px;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
    z-index: 1000;
    border: 1px solid rgba(0, 0, 0, 0.08);
    animation: slideUp 0.2s ease;
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.emoji-option {
    cursor: pointer;
    padding: 6px;
    border-radius: 6px;
    text-align: center;
    transition: all 0.2s ease;
    font-size: 16px;
    line-height: 1;
}

.emoji-option:hover {
    background: #f0f3f5;
    transform: scale(1.1);
}

.add-reaction {
    padding: 2px 8px;
    cursor: pointer;
    border-radius: 14px;
    background: #ffffff;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: all 0.2s ease;
    position: relative;
    font-size: 14px;
}

.add-reaction:hover {
    background: #f0f3f5;
    transform: scale(1.1);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.timestamp {
    color: #657786;
    font-size: 13px;
    margin-left: auto;
    transition: color 0.2s ease;
}

/* Dark mode styles */
body.theme-dark {
    background-color: #000000;
    color: #ffffff;
}

body.theme-dark .message-bubble {
    background-color: #16181c;
    border-color: #2f3336;
}

body.theme-dark .reaction {
    background: #16181c;
    border-color: #2f3336;
    color: #e6e9ea;
}

body.theme-dark .reaction:hover {
    background: #1d2023;
}

body.theme-dark .reaction.user-reacted {
    background: rgba(29, 161, 242, 0.2);
    color: #1da1f2;
}

body.theme-dark .username {
    color: #ffffff;
}

body.theme-dark .timestamp {
    color: #8899a6;
}

body.theme-dark .media-wrapper {
    background: #16181c;
    border-color: #2f3336;
}

body.theme-dark .add-reaction {
    background: #16181c;
    border-color: #2f3336;
}

body.theme-dark .add-reaction:hover {
    background: #1d2023;
}

body.theme-dark .emoji-picker {
    background: #16181c;
    border-color: #2f3336;
}

body.theme-dark .emoji-option:hover {
    background: #1d2023;
}

/* Dim mode styles */
body.theme-dim {
    background-color: #15202b;
    color: #ffffff;
}

body.theme-dim .message-bubble {
    background-color: #192734;
    border-color: #38444d;
}

body.theme-dim .reaction {
    background: #192734;
    border-color: #38444d;
    color: #e6e9ea;
}

body.theme-dim .reaction:hover {
    background: #1e2c3a;
}

body.theme-dim .reaction.user-reacted {
    background: rgba(29, 161, 242, 0.2);
    color: #1da1f2;
}

body.theme-dim .username {
    color: #ffffff;
}

body.theme-dim .timestamp {
    color: #8899a6;
}

body.theme-dim .media-wrapper {
    background: #192734;
    border-color: #38444d;
}

body.theme-dim .add-reaction {
    background: #192734;
    border-color: #38444d;
}

body.theme-dim .add-reaction:hover {
    background: #1e2c3a;
}

body.theme-dim .emoji-picker {
    background: #192734;
    border-color: #38444d;
}

body.theme-dim .emoji-option:hover {
    background: #1e2c3a;
}

/* Message animation variations */
.message:nth-child(3n+1) {
    animation-delay: 0.05s;
}

.message:nth-child(3n+2) {
    animation-delay: 0.1s;
}

.message:nth-child(3n+3) {
    animation-delay: 0.15s;
}

/* Error message styling */
.error {
    padding: 16px;
    margin: 20px auto;
    border-radius: 16px;
    background-color: rgba(224, 36, 94, 0.1);
    color: #e0245e;
    text-align: center;
    max-width: 80%;
    border: 1px solid rgba(224, 36, 94, 0.2);
    animation: fadeIn 0.3s ease;
}

body.theme-dark .error, 
body.theme-dim .error {
    background-color: rgba(224, 36, 94, 0.2);
    color: #f4a5be;
}

/* Follow button styles */
.follow-btn {
    background-color: transparent;
    color: #626262;
    border: 1px solid #626262;
    border-radius: 9999px;
    padding: 3px 12px;
    font-weight: 600;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.25s cubic-bezier(0.2, 0, 0, 1);
    position: relative;
    overflow: hidden;
    min-width: 70px;
    margin-left: auto;
}

.follow-btn.followed {
    background: linear-gradient(
        135deg,  
        #0f0f0f 0%,  
        #1c1c1c 15%,  
        #3a3a3a 30%,  
        #4d4d4d 45%,  
        #626262 60%,  
        #787878 75%,  
        #8f8f8f 90%,  
        #a6a6a6 100%
    );
    color: white;
    border: 1px solid transparent;
}

.follow-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.follow-btn:active {
    transform: translateY(0px);
}

.follow-btn .loading-spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid rgba(98, 98, 98, 0.1);
    border-radius: 50%;
    border-top-color: #626262;
    animation: spin 0.8s cubic-bezier(0.5, 0.1, 0.4, 0.9) infinite;
    margin: 0;
}

.follow-btn.followed .loading-spinner {
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-top-color: #ffffff;
}

.user-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}

.user-info {
    display: flex;
    align-items: center;
}

/* Responsive improvements */
@media (max-width: 480px) {
    .follow-btn {
        padding: 2px 8px;
        font-size: 11px;
        min-width: 60px;
    }
    
    .reaction {
        padding: 1px 6px;
        font-size: 11px;
    }
    
    .emoji-picker {
        grid-template-columns: repeat(5, 1fr);
    }
}

    </style>
</head>
<body>
    <div class="chat-container" id="chat-container"></div>
    <div class="header-space"></div>

   


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
    import { getFirestore, collection, query, orderBy, limit, getDocs, doc, getDoc, updateDoc, arrayUnion, arrayRemove, onSnapshot, startAfter, where, addDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyDnPz8BWCaXJOazlFVO4Eap8VxdSR2oDFQ",
        authDomain: "globalchat-2d669.firebaseapp.com",
        projectId: "globalchat-2d669",
        storageBucket: "globalchat-2d669.firebasestorage.app",
        messagingSenderId: "178714711978",
        appId: "1:178714711978:web:fb831188be23e62a4bbdd3"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const MESSAGES_PER_PAGE = 15;
    let lastVisible = null;
    let loading = false;
    let realtimeUnsubscribe = null;
    let hasMoreMessages = true;
    let userProfileCache = {};
    let followStatusCache = {};
    let allLoadedPosts = []; // Store all loaded posts for randomization

    const commonEmojis = ['👍', '❤️', '😂', '😮', '😢', '🙏'];
    const chatContainer = document.getElementById('chat-container');

    // Intersection Observer for media loading
    const mediaObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const mediaWrapper = entry.target;
                const mediaElement = mediaWrapper.querySelector('img, video');
                
                if (mediaElement && mediaElement.dataset.src) {
                    mediaElement.src = mediaElement.dataset.src;
                    mediaElement.onload = () => {
                        mediaWrapper.classList.remove('media-loading');
                    };
                    mediaElement.onerror = () => {
                        mediaWrapper.classList.remove('media-loading');
                        mediaWrapper.classList.add('media-error');
                    };
                    mediaObserver.unobserve(mediaWrapper);
                }
            }
        });
    }, {
        rootMargin: '200px',
        threshold: 0.1
    });

    // Scroll Observer for Infinite Loading
    const scrollObserver = new IntersectionObserver((entries) => {
        const lastEntry = entries[0];
        if (lastEntry.isIntersecting && hasMoreMessages && !loading) {
            loadMessages(false);
        }
    }, {
        rootMargin: '300px',
        threshold: 0.1
    });

    async function getUserProfile(userId) {
        if (userProfileCache[userId]) {
            return userProfileCache[userId];
        }
        
        try {
            const userDocRef = doc(db, 'users', userId);
            const userDoc = await getDoc(userDocRef);
            const userData = userDoc.exists() ? userDoc.data() : null;
            
            if (userData) {
                userProfileCache[userId] = userData;
            }
            
            return userData;
        } catch (error) {
            console.error('Error fetching user profile:', error);
            return null;
        }
    }

    async function isFollowing(currentUserId, targetUserId) {
        if (!currentUserId || !targetUserId || currentUserId === targetUserId) {
            return false;
        }
        
        const cacheKey = `${currentUserId}_${targetUserId}`;
        if (followStatusCache[cacheKey] !== undefined) {
            return followStatusCache[cacheKey];
        }
        
        try {
            const followQuery = query(
                collection(db, 'follows'),
                where('followerUserId', '==', currentUserId),
                where('followedUserId', '==', targetUserId)
            );
            
            const followSnapshot = await getDocs(followQuery);
            const result = !followSnapshot.empty;
            
            followStatusCache[cacheKey] = result;
            
            return result;
        } catch (error) {
            console.error('Error checking follow status:', error);
            return false;
        }
    }

    async function toggleFollow(userId, userName, button) {
        const currentUser = auth.currentUser;
        
        if (!currentUser) {
            alert('Please log in to follow users');
            return;
        }

        try {
            button.disabled = true;
            button.innerHTML = '<span class="loading-spinner"></span>';

            const cacheKey = `${currentUser.uid}_${userId}`;
            
            const followQuery = query(
                collection(db, 'follows'),
                where('followerUserId', '==', currentUser.uid),
                where('followedUserId', '==', userId)
            );
            
            const followSnapshot = await getDocs(followQuery);

            if (followSnapshot.empty) {
                await addDoc(collection(db, 'follows'), {
                    followerUserId: currentUser.uid,
                    followedUserId: userId,
                    followedUserName: userName,
                    timestamp: new Date()
                });
                
                followStatusCache[cacheKey] = true;
                
                setTimeout(() => {
                    button.innerHTML = 'Following';
                    button.classList.add('followed');
                    button.disabled = false;
                }, 300);
            } else {
                followSnapshot.forEach(async (doc) => {
                    await deleteDoc(doc.ref);
                });
                
                followStatusCache[cacheKey] = false;
                
                setTimeout(() => {
                    button.innerHTML = 'Follow';
                    button.classList.remove('followed');
                    button.disabled = false;
                }, 300);
            }
        } catch (error) {
            console.error('Follow/Unfollow error:', error);
            button.disabled = false;
            button.innerHTML = 'Follow';
            button.classList.remove('followed');
        }
    }

    function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        const diffDays = Math.floor(diffHours / 24);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        
        return date.toLocaleDateString();
    }
    
    function getDateHeader(timestamp) {
        if (!timestamp) return '';
        
        const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
        const now = new Date();
        const yesterday = new Date(now);
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (date.toDateString() === now.toDateString()) {
            return 'Today';
        }
        
        if (date.toDateString() === yesterday.toDateString()) {
            return 'Yesterday';
        }
        
        const diffDays = Math.floor((now - date) / (24 * 60 * 60 * 1000));
        if (diffDays < 7) {
            return date.toLocaleDateString(undefined, { weekday: 'long' });
        }
        
        if (date.getFullYear() === now.getFullYear()) {
            return date.toLocaleDateString(undefined, { month: 'long', day: 'numeric' });
        }
        
        return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
    }

    async function toggleReaction(postId, emoji, userId) {
        try {
            const postRef = doc(db, 'posts', postId);
            const postDoc = await getDoc(postRef);
            
            if (!postDoc.exists()) return;
            
            const reactions = postDoc.data().reactions || {};
            const reactionUsers = reactions[emoji] || [];
            
            if (reactionUsers.includes(userId)) {
                await updateDoc(postRef, {
                    [`reactions.${emoji}`]: arrayRemove(userId)
                });
            } else {
                await updateDoc(postRef, {
                    [`reactions.${emoji}`]: arrayUnion(userId)
                });
            }
        } catch (error) {
            console.error('Error toggling reaction:', error);
        }
    }

    function createEmojiPicker(postId, userId) {
        const picker = document.createElement('div');
        picker.className = 'emoji-picker';
        
        commonEmojis.forEach(emoji => {
            const option = document.createElement('div');
            option.className = 'emoji-option';
            option.textContent = emoji;
            option.onclick = (e) => {
                e.stopPropagation();
                toggleReaction(postId, emoji, userId);
                picker.remove();
            };
            picker.appendChild(option);
        });
        
        return picker;
    }

    function renderReactions(reactions = {}, postId, userId) {
        const container = document.createElement('div');
        container.className = 'reactions-container';
        
        Object.entries(reactions).forEach(([emoji, users]) => {
            if (users.length > 0) {
                const reaction = document.createElement('div');
                reaction.className = 'reaction';
                reaction.classList.toggle('user-reacted', users.includes(userId));
                reaction.innerHTML = `
                    ${emoji}
                    <span class="reaction-count">${users.length}</span>
                `;
                reaction.onclick = () => toggleReaction(postId, emoji, userId);
                container.appendChild(reaction);
            }
        });
        
        const addReaction = document.createElement('div');
        addReaction.className = 'add-reaction';
        addReaction.innerHTML = '😊';
        addReaction.onclick = (e) => {
            e.stopPropagation();
            const existing = document.querySelector('.emoji-picker');
            if (existing) existing.remove();
            
            const picker = createEmojiPicker(postId, userId);
            addReaction.appendChild(picker);
            
            document.addEventListener('click', () => picker.remove(), { once: true });
        };
        
        // Share button with SVG icons
        const shareButton = document.createElement('div');
        shareButton.className = 'share-button';
        shareButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                <polyline points="16 6 12 2 8 6"></polyline>
                <line x1="12" y1="2" x2="12" y2="15"></line>
            </svg>
        `;
        shareButton.onclick = (e) => {
            e.stopPropagation();
            sharePost(postId);
        };
        
        container.appendChild(addReaction);
        container.appendChild(shareButton);
        
        return container;
    }

    function sharePost(postId) {
        // Create a URL to share
        const shareUrl = `${window.location.origin}/post.html?id=${postId}`;
        
        // Check if Web Share API is supported
        if (navigator.share) {
            navigator.share({
                title: 'Check out this post',
                url: shareUrl
            }).catch(console.error);
        } else {
            // Fallback - copy to clipboard
            navigator.clipboard.writeText(shareUrl)
                .then(() => {
                    // Show toast notification
                    const toast = document.createElement('div');
                    toast.className = 'toast';
                    toast.textContent = 'Link copied to clipboard!';
                    document.body.appendChild(toast);
                    
                    // Remove toast after 3 seconds
                    setTimeout(() => {
                        toast.classList.add('toast-hide');
                        setTimeout(() => toast.remove(), 300);
                    }, 3000);
                })
                .catch(err => console.error('Failed to copy: ', err));
        }
    }

    function createMediaElement(post) {
        if (!post.mediaUrl) return null;

        const mediaWrapper = document.createElement('div');
        mediaWrapper.className = 'media-wrapper media-loading';

        const isVideo = post.mediaType?.startsWith('video/') || post.mediaUrl?.match(/\.(mp4|webm|ogg)$/i);
        
        if (isVideo) {
            const video = document.createElement('video');
            video.className = 'post-media post-video';
            video.controls = false;
            video.preload = 'none';
            video.autoplay = true;
            video.muted = true;
            video.dataset.src = post.mediaUrl;
            video.playsInline = true;
            
            if (post.thumbnailUrl) {
                video.poster = post.thumbnailUrl;
            }

            video.onloadeddata = () => {
                mediaWrapper.classList.remove('media-loading');
            };

            mediaWrapper.appendChild(video);
        } else {
            const img = document.createElement('img');
            img.className = 'post-media post-image';
            img.dataset.src = post.mediaUrl;
            img.alt = "Posted image";
            
            mediaWrapper.appendChild(img);
        }

        mediaObserver.observe(mediaWrapper);
        return mediaWrapper;
    }

    function createDateSeparator(dateText) {
        const separator = document.createElement('div');
        separator.className = 'date-separator';
        separator.innerHTML = `<span>${dateText}</span>`;
        return separator;
    }

    async function createMessageElement(post, userId) {
        const userProfile = await getUserProfile(post.userId);
        const username = userProfile?.displayName || `User ${post.userId.slice(0, 4)}`;
        const profilePic = userProfile?.photoURL || "/api/placeholder/40/40";
        
        const followingStatus = post.userId !== userId ? await isFollowing(userId, post.userId) : false;

        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        messageDiv.dataset.postId = post.id;
        messageDiv.dataset.userId = post.userId;
        messageDiv.dataset.timestamp = post.createdAt?.toDate ? post.createdAt.toDate().getTime() : 0;
        
        // Add a random offset value for display order
        messageDiv.dataset.randomOrder = Math.random();
        
        const followButton = document.createElement('button');
        followButton.className = 'follow-btn';
        if (followingStatus) {
            followButton.classList.add('followed');
            followButton.textContent = 'Following';
        } else {
            followButton.textContent = 'Follow';
        }
        
        const showFollowButton = post.userId !== userId;
        
        const messageHeader = document.createElement('div');
        messageHeader.className = 'user-header';
        
        messageHeader.innerHTML = `
            <div class="user-info">
                <div class="status-indicator"></div>
                <span class="username">${username}</span>
                <span class="timestamp">${formatTimestamp(post.createdAt)}</span>
            </div>
        `;
        
        if (showFollowButton) {
            followButton.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFollow(post.userId, username, followButton);
            });
            messageHeader.appendChild(followButton);
        }
        
        const messageBubble = document.createElement('div');
        messageBubble.className = 'message-bubble';
        messageBubble.appendChild(messageHeader);
        
        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        
        if (post.text) {
            const textElement = document.createElement('p');
            textElement.className = 'text-content';
            textElement.textContent = post.text;
            messageContent.appendChild(textElement);
        }
        
        messageBubble.appendChild(messageContent);
        
        messageDiv.innerHTML = `<img src="${profilePic}" alt="Profile" class="profile-pic">`;
        messageDiv.appendChild(messageBubble);
        
        if (post.mediaUrl) {
            const mediaElement = createMediaElement(post);
            if (mediaElement) {
                messageContent.appendChild(mediaElement);
            }
        }

        messageBubble.appendChild(renderReactions(post.reactions, post.id, userId));

        return messageDiv;
    }

    function updateMessage(post, userId) {
        const existingMessage = document.querySelector(`.message[data-post-id="${post.id}"]`);
        if (existingMessage) {
            const messageBubble = existingMessage.querySelector('.message-bubble');
            const oldReactions = messageBubble.querySelector('.reactions-container');
            if (oldReactions) {
                oldReactions.replaceWith(renderReactions(post.reactions, post.id, userId));
            }
        }
    }

    function createLoadingSpinner() {
        const spinner = document.createElement('div');
        spinner.className = 'loading-spinner';
        spinner.id = 'loading-spinner';
        spinner.innerHTML = `
            <div class="spinner-inner">
                <div class="spinner-circle"></div>
            </div>
        `;
        return spinner;
    }

    // Shuffle array using Fisher-Yates algorithm
    function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }

    // Display posts in a random order
    function displayRandomizedPosts(container, messageElements) {
        // Clear container first
        container.innerHTML = '';
        
        // Shuffle the message elements
        const shuffledElements = shuffleArray(messageElements);
        
        // Group by date, but still maintain randomization within dates
        let lastDate = null;
        
        // Sort only by date, but maintain randomization within each date
        shuffledElements.sort((a, b) => {
            const aDate = new Date(parseInt(a.dataset.timestamp)).toDateString();
            const bDate = new Date(parseInt(b.dataset.timestamp)).toDateString();
            
            if (aDate === bDate) {
                // For same date, use the random value
                return parseFloat(a.dataset.randomOrder) - parseFloat(b.dataset.randomOrder);
            }
            
            // For different dates, sort by date
            return parseInt(a.dataset.timestamp) - parseInt(b.dataset.timestamp);
        });
        
        // Add elements with date separators
        shuffledElements.forEach(element => {
            const timestamp = parseInt(element.dataset.timestamp);
            if (!timestamp) {
                container.appendChild(element);
                return;
            }
            
            const messageDate = new Date(timestamp);
            const dateHeader = getDateHeader(messageDate);
            
            if (dateHeader !== lastDate) {
                container.appendChild(createDateSeparator(dateHeader));
                lastDate = dateHeader;
            }
            
            container.appendChild(element);
        });
        
        return shuffledElements;
    }

    async function loadMessages(initial = true) {
        if (loading || (!initial && !hasMoreMessages)) return;
        loading = true;

        const container = document.getElementById('chat-container');
        const loadingSpinner = createLoadingSpinner();
        
        if (initial) {
            container.innerHTML = '';
            container.appendChild(loadingSpinner);
            
            if (realtimeUnsubscribe) {
                realtimeUnsubscribe();
            }
            
            // Reset stored posts on initial load
            allLoadedPosts = [];
        } else {
            container.appendChild(loadingSpinner);
        }

        try {
            let messagesQuery = query(
                collection(db, 'posts'),
                orderBy('createdAt', 'desc'),
                limit(MESSAGES_PER_PAGE)
            );

            if (!initial && lastVisible) {
                messagesQuery = query(
                    collection(db, 'posts'),
                    orderBy('createdAt', 'desc'),
                    startAfter(lastVisible),
                    limit(MESSAGES_PER_PAGE)
                );
            }

            const snapshot = await getDocs(messagesQuery);
            
            if (snapshot.empty || snapshot.docs.length < MESSAGES_PER_PAGE) {
                hasMoreMessages = false;
            }

            if (snapshot.empty) {
                const spinner = document.getElementById('loading-spinner');
                if (spinner) spinner.remove();
                loading = false;
                
                if (initial && allLoadedPosts.length === 0) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.className = 'empty-state';
                    emptyMessage.textContent = 'No posts yet. Be the first to share something!';
                    container.appendChild(emptyMessage);
                }
                
                return;
            }

            lastVisible = snapshot.docs[snapshot.docs.length - 1];

            if (initial) {
                realtimeUnsubscribe = onSnapshot(
                    query(collection(db, 'posts'), orderBy('createdAt', 'desc'), limit(30)),
                    (snapshot) => {
                        const currentUser = auth.currentUser;
                        
                        snapshot.docChanges().forEach((change) => {
                            const post = { id: change.doc.id, ...change.doc.data() };
                            if (change.type === 'modified') {
                                updateMessage(post, currentUser.uid);
                            }
                        });
                    }
                );
            }

            const currentUser = auth.currentUser;
            const messagePromises = [];
            
            // Create message elements concurrently
            for (const doc of snapshot.docs) {
                const post = { id: doc.id, ...doc.data() };
                messagePromises.push(createMessageElement(post, currentUser.uid));
            }
            
            // Wait for all message elements to be created
            const newMessageElements = await Promise.all(messagePromises);
            
            // Add new elements to the collection of all loaded posts
            allLoadedPosts = [...allLoadedPosts, ...newMessageElements];
            
            // Remove the loading spinner after messages are ready
            const spinner = document.getElementById('loading-spinner');
            if (spinner) spinner.remove();
            
            // Display randomized posts
            const displayedElements = displayRandomizedPosts(container, allLoadedPosts);
            
            // Observe the last element for infinite scrolling
            if (hasMoreMessages && displayedElements.length > 0) {
                // Use the actual last element in the DOM after randomization
                const lastElement = container.querySelector('.message:last-child');
                if (lastElement) {
                    scrollObserver.observe(lastElement);
                }
            }

        } catch (error) {
            console.error('Messages loading error:', error);
            const spinner = document.getElementById('loading-spinner');
            if (spinner) spinner.remove();
            
            if (initial) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = 'Error loading messages. Please try again later.';
                container.appendChild(errorDiv);
            }
        }

        loading = false;
    }

    // Add CSS for new elements
    const styleSheet = document.createElement("style");
    styleSheet.innerHTML = `
        .date-separator {
            text-align: center;
            margin: 15px 0;
            position: relative;
            z-index: 1;
        }
        
        .date-separator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background-color: rgba(0, 0, 0, 0.1);
            z-index: -1;
        }
        
        body.theme-dark .date-separator::before,
        body.theme-dim .date-separator::before {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .date-separator span {
            background-color: #ffffff;
            padding: 0 10px;
            font-size: 12px;
            color: #657786;
            font-weight: 500;
            border-radius: 10px;
            display: inline-block;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        body.theme-dark .date-separator span {
            background-color: #16181c;
            color: #8899a6;
        }
        
        body.theme-dim .date-separator span {
            background-color: #192734;
            color: #8899a6;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #657786;
            font-size: 16px;
        }
        
        .share-button {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #ffffff;
            border-radius: 14px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.08);
            transition: all 0.2s ease;
            margin-left: 4px;
        }
        
        .share-button:hover {
            background: #f0f3f5;
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        body.theme-dark .share-button {
            background: #16181c;
            border-color: #2f3336;
            color: #e6e9ea;
        }
        
        body.theme-dark .share-button:hover {
            background: #1d2023;
        }
        
        body.theme-dim .share-button {
            background: #192734;
            border-color: #38444d;
            color: #e6e9ea;
        }
        
        body.theme-dim .share-button:hover {
            background: #1e2c3a;
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 1000;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        .toast-hide {
            opacity: 0;
        }
    `;
    document.head.appendChild(styleSheet);

    // Initialize the chat
    onAuthStateChanged(auth, (user) => {
        if (user) {
            loadMessages(true);
        } else {
            window.location.href = 'login.html';
        }
    });

    // Clean up
    window.addEventListener('unload', () => {
        if (realtimeUnsubscribe) {
            realtimeUnsubscribe();
        }
        mediaObserver.disconnect();
        scrollObserver.disconnect();
    });
</script>

<script>
  (function() {
    const GlobalChatThemeManager = {
      themeConfig: {
        light: {
          '--bg-color': '#ffffff',
          '--text-primary': '#0f1419',
          '--text-secondary': '#657786',
          '--message-bubble': '#f7f9fa',
          '--border-color': 'rgba(0, 0, 0, 0.08)',
          '--message-hover': 'rgba(0, 0, 0, 0.02)',
          '--reaction-bg': '#ffffff',
          '--reaction-hover': '#f0f3f5',
          '--media-bg': '#f7f9fa',
          '--emoji-picker-bg': '#ffffff',
          '--emoji-hover': '#f0f3f5',
          '--status-indicator': '#1da1f2',
          '--profile-pic-border': 'rgba(0, 0, 0, 0.08)',
          
          // Follow button (your exact branding)
          '--follow-btn-text': '#626262',
          '--follow-btn-border': '#626262',
          '--follow-btn-hover': 'rgba(98, 98, 98, 0.08)',
          '--followed-btn-gradient': 'linear-gradient(135deg, #0f0f0f 0%, #1c1c1c 15%, #3a3a3a 30%, #4d4d4d 45%, #626262 60%, #787878 75%, #8f8f8f 90%, #a6a6a6 100%)',
          '--followed-btn-text': '#ffffff',
          '--follow-spinner': 'rgba(98, 98, 98, 0.1)',
          '--follow-spinner-top': '#626262'
        },
        dim: {
          '--bg-color': '#15202b',
          '--text-primary': '#ffffff',
          '--text-secondary': '#8899a6',
          '--message-bubble': '#192734',
          '--border-color': '#38444d',
          '--message-hover': 'rgba(29, 161, 242, 0.05)',
          '--reaction-bg': '#192734',
          '--reaction-hover': '#1e2c3a',
          '--media-bg': '#192734',
          '--emoji-picker-bg': '#192734',
          '--emoji-hover': '#1e2c3a',
          '--status-indicator': '#1da1f2',
          '--profile-pic-border': '#38444d',
          
          // Follow button (your exact branding)
          '--follow-btn-text': '#ffffff',
          '--follow-btn-border': '#8899a6',
          '--follow-btn-hover': 'rgba(136, 153, 166, 0.1)',
          '--followed-btn-gradient': 'linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 15%, #d8d8d8 30%, #c8c8c8 45%, #b8b8b8 60%, #a8a8a8 75%, #989898 90%, #888888 100%)',
          '--followed-btn-text': '#000000',
          '--follow-spinner': 'rgba(136, 153, 166, 0.1)',
          '--follow-spinner-top': '#8899a6'
        },
        dark: {
          '--bg-color': '#000000',
          '--text-primary': '#ffffff',
          '--text-secondary': '#a6a6a6',
          '--message-bubble': '#16181c',
          '--border-color': '#2f3336',
          '--message-hover': 'rgba(29, 161, 242, 0.05)',
          '--reaction-bg': '#16181c',
          '--reaction-hover': '#1d2023',
          '--media-bg': '#16181c',
          '--emoji-picker-bg': '#16181c',
          '--emoji-hover': '#1d2023',
          '--status-indicator': '#1da1f2',
          '--profile-pic-border': '#2f3336',
          
         // Follow button (your exact branding)
'--follow-btn-text': '#ffffff',
'--follow-btn-border': '#8899a6',
'--follow-btn-hover': 'rgba(136, 153, 166, 0.1)',
'--followed-btn-gradient': 'linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 15%, #d8d8d8 30%, #c8c8c8 45%, #b8b8b8 60%, #a8a8a8 75%, #989898 90%, #888888 100%)',
'--followed-btn-text': '#000000',
'--follow-spinner': 'rgba(136, 153, 166, 0.1)',
'--follow-spinner-top': '#8899a6'
}
      },
      
      styleElementId: 'global-chat-theme-styles',
      currentTheme: 'light',
      
      initialize: function() {
        this.createStyleElement();
        this.currentTheme = localStorage.getItem('twitter-theme') || 'light';
        this.applyTheme(this.currentTheme);
        this.setupEventListeners();
      },
      
      createStyleElement: function() {
        const existingStyle = document.getElementById(this.styleElementId);
        if (existingStyle) existingStyle.remove();
        
        const styleElement = document.createElement('style');
        styleElement.id = this.styleElementId;
        document.head.appendChild(styleElement);
      },
      
      applyTheme: function(themeName) {
        const theme = this.themeConfig[themeName] || this.themeConfig.light;
        this.currentTheme = themeName;
        localStorage.setItem('twitter-theme', themeName);
        
        const styleElement = document.getElementById(this.styleElementId);
        if (!styleElement) {
          this.createStyleElement();
          return this.applyTheme(themeName);
        }
        
        // Generate CSS variables
        let css = ':root {';
        for (const [key, value] of Object.entries(theme)) {
          css += `${key}: ${value};`;
        }
        css += '}';
        
        // Add comprehensive component styles
        css += `
          body {
            background-color: var(--bg-color);
            color: var(--text-primary);
          }
          
          .message-bubble {
            background-color: var(--message-bubble);
            border-color: var(--border-color);
          }
          
          .message:hover {
            background-color: var(--message-hover);
          }
          
          .reaction {
            background-color: var(--reaction-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
          }
          
          .reaction:hover {
            background-color: var(--reaction-hover);
          }
          
          .reaction.user-reacted {
            background: rgba(29, 161, 242, 0.1);
            color: #1da1f2;
            border-color: rgba(29, 161, 242, 0.2);
          }
          
          .media-wrapper {
            background-color: var(--media-bg);
            border-color: var(--border-color);
          }
          
          .username, .text-content {
            color: var(--text-primary);
          }
          
          .timestamp {
            color: var(--text-secondary);
          }
          
          .status-indicator {
            background-color: var(--status-indicator);
            box-shadow: 0 0 0 rgba(29, 161, 242, 0.4);
          }
          
          .profile-pic {
            border-color: var(--profile-pic-border);
          }
          
          .emoji-picker {
            background-color: var(--emoji-picker-bg);
            border-color: var(--border-color);
          }
          
          .emoji-option:hover {
            background-color: var(--emoji-hover);
          }
          
          /* Follow button styles - your exact branding */
          .follow-btn {
            background-color: transparent;
            color: var(--follow-btn-text);
            border: 1px solid var(--follow-btn-border);
          }
          
          .follow-btn:hover {
            background-color: var(--follow-btn-hover);
          }
          
          .follow-btn.followed {
            background: var(--followed-btn-gradient);
            color: var(--followed-btn-text);
            border: 1px solid transparent;
          }
          
          .follow-btn .loading-spinner {
            border: 2px solid var(--follow-spinner);
            border-top-color: var(--follow-spinner-top);
          }
          
          .follow-btn.followed .loading-spinner {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top-color: #ffffff;
          }
        `;
        
        styleElement.textContent = css;
        
        // Add theme class to body
        document.body.className = `theme-${themeName}`;
      },
      
      setupEventListeners: function() {
        window.addEventListener('storage', (e) => {
          if (e.key === 'twitter-theme') {
            this.applyTheme(e.newValue || 'light');
          }
        });
        
        // Setup periodic check for theme changes
        setInterval(() => {
          const storedTheme = localStorage.getItem('twitter-theme') || 'light';
          if (storedTheme !== this.currentTheme) {
            this.applyTheme(storedTheme);
          }
        }, 1000);
      }
    };
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => GlobalChatThemeManager.initialize());
    } else {
      GlobalChatThemeManager.initialize();
    }
  })();
</script>

  <script>


(function() {
  // Search Page Profile Placeholder Generator
  const SearchProfilePlaceholderGenerator = {
    // Color palette based on first letter (26 colors for 26 letters)
    letterColors: {
      'a': '#F44336', 'b': '#E91E63', 'c': '#9C27B0', 'd': '#673AB7',
      'e': '#3F51B5', 'f': '#2196F3', 'g': '#03A9F4', 'h': '#00BCD4',
      'i': '#009688', 'j': '#4CAF50', 'k': '#8BC34A', 'l': '#CDDC39',
      'm': '#FFEB3B', 'n': '#FFC107', 'o': '#FF9800', 'p': '#FF5722',
      'q': '#795548', 'r': '#9E9E9E', 's': '#607D8B', 't': '#3949AB',
      'u': '#D32F2F', 'v': '#C2185B', 'w': '#7B1FA2', 'x': '#512DA8',
      'y': '#303F9F', 'z': '#1976D2'
    },
    
    // Lighter background colors that need dark text
    needsDarkText: ['l', 'm', 'n'],
    
    init: function() {
      // Use a unique namespace for this search page functionality
      if (window.searchProfilePlaceholdersInitialized) return;
      window.searchProfilePlaceholdersInitialized = true;
      
      // Initial processing with delay to ensure DOM is fully loaded
      setTimeout(() => {
        this.processSearchPageImages();
      }, 500);
      
      // Set up observer for dynamically added content
      this.setupSearchObserver();
    },
    
    processSearchPageImages: function() {
      // Process all profile pictures in the search container
      document.querySelectorAll('.chat-container .profile-pic').forEach(img => {
        this.processProfileImage(img);
      });
    },
    
    processProfileImage: function(imgElement) {
      // Use a different data attribute to avoid conflicts
      if (imgElement.dataset.searchPlaceholderApplied === 'true') return;
      
      // Mark as processed with our unique attribute
      imgElement.dataset.searchPlaceholderApplied = 'true';
      
      // Get image source
      const imgSrc = imgElement.getAttribute('src');
      
      // Check if it's a default, placeholder or error profile image
      const isDefaultImage = !imgSrc || 
                             imgSrc.includes('default_profile') || 
                             imgSrc.includes('placeholder') ||
                             imgSrc === '' || 
                             imgSrc === 'undefined';
      
      if (isDefaultImage) {
        const name = this.getNameFromContext(imgElement);
        if (name) {
          this.createProfilePlaceholder(imgElement, name);
        }
      }
      
      // Also handle image error cases
      imgElement.onerror = () => {
        const name = this.getNameFromContext(imgElement);
        if (name) {
          this.createProfilePlaceholder(imgElement, name);
          // Prevent infinite error loop
          imgElement.onerror = null;
        }
      };
    },
    
    getNameFromContext: function(imgElement) {
      let name = '';
      
      // Try to extract name from username element
      const messageElement = imgElement.closest('.message');
      if (messageElement) {
        const usernameElement = messageElement.querySelector('.username');
        if (usernameElement && usernameElement.textContent) {
          name = usernameElement.textContent.trim();
        }
      }
      
      // Fallback to alt attribute
      if (!name && imgElement.alt) {
        name = imgElement.alt;
      }
      
      return name || 'User';
    },
    
    createProfilePlaceholder: function(imgElement, name) {
      // Get first letter (normalized to lowercase for color mapping)
      const firstLetter = name.trim().charAt(0).toLowerCase();
      
      // Get background color based on first letter
      const backgroundColor = this.letterColors[firstLetter] || '#607D8B';
      
      // Determine text color (white or dark gray)
      const textColor = this.needsDarkText.includes(firstLetter) ? '#202124' : '#FFFFFF';
      
      // Create canvas element
      const canvas = document.createElement('canvas');
      const size = Math.max(imgElement.width || 40, imgElement.height || 40, 40);
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Draw circular background
      ctx.fillStyle = backgroundColor;
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw letter
      ctx.fillStyle = textColor;
      ctx.font = `bold ${size * 0.45}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(name.charAt(0).toUpperCase(), size/2, size/2);
      
      // Replace image source with canvas data URL
      imgElement.src = canvas.toDataURL('image/png');
    },
    
    setupSearchObserver: function() {
      // Create mutation observer specific for search page
      const searchObserver = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          // Check for new nodes
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(node => {
              // Check if node is an element
              if (node.nodeType === 1) {
                // Check for profile pictures inside the added node
                const profileImages = node.querySelectorAll('.profile-pic');
                if (profileImages.length > 0) {
                  profileImages.forEach(img => this.processProfileImage(img));
                }
                
                // If the node itself is a profile picture
                if (node.classList && node.classList.contains('profile-pic')) {
                  this.processProfileImage(node);
                }
              }
            });
          }
          
          // Check for attribute changes that might indicate new src
          if (mutation.type === 'attributes' && 
              mutation.attributeName === 'src' && 
              mutation.target.classList && 
              mutation.target.classList.contains('profile-pic')) {
            this.processProfileImage(mutation.target);
          }
        });
      });
      
      // Start observing the chat container
      const chatContainer = document.getElementById('chat-container');
      if (chatContainer) {
        searchObserver.observe(chatContainer, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['src']
        });
      }
    }
  };
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      SearchProfilePlaceholderGenerator.init();
    });
  } else {
    // If DOM is already loaded, initialize with delay
    setTimeout(() => {
      SearchProfilePlaceholderGenerator.init();
    }, 100);
  }
})();


  </script>
<script>
  
// Ultimate Date Headers with Enhanced Timestamps for Professional Chat
(function() {
  // Configuration - Customizable gradient
  const HEADER_GRADIENT = 'linear-gradient(135deg, rgba(98,98,98,0.8) 0%, rgba(72,72,72,0.9) 100%)';
  
  // Enhanced timestamp formatter that works with the actual chat platform
  function enhancedFormatTimestamp(timestamp) {
    const messageDate = new Date(timestamp);
    const now = new Date();
    
    // Format time as HH:MM
    const hours = messageDate.getHours();
    const minutes = messageDate.getMinutes().toString().padStart(2, '0');
    const timeString = `${hours}:${minutes}`;
    
    // Check if it's today
    if (messageDate.toDateString() === now.toDateString()) {
      return `Today at ${timeString}`;
    }
    
    // Check if it's yesterday
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    if (messageDate.toDateString() === yesterday.toDateString()) {
      return `Yesterday at ${timeString}`;
    }
    
    // Check if it's within the last week
    const oneWeekAgo = new Date(now);
    oneWeekAgo.setDate(now.getDate() - 7);
    if (messageDate > oneWeekAgo) {
      // Get day of week
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const dayOfWeek = days[messageDate.getDay()];
      return `${dayOfWeek} at ${timeString}`;
    }
    
    // Otherwise show full date
    const month = messageDate.toLocaleString('default', { month: 'short' });
    const day = messageDate.getDate();
    return `${month} ${day} at ${timeString}`;
  }
  
  // Function to update all message timestamps in the interface
  function updateAllTimestamps() {
    const timeElements = document.querySelectorAll('.message-time');
    timeElements.forEach(element => {
      // Extract timestamp from data attribute if available
      const messageElement = element.closest('.message');
      if (messageElement) {
        const messageId = messageElement.getAttribute('data-message-id');
        // Try to find the timestamp from local storage
        try {
          const localMessages = localStorage.getItem('localMessages');
          if (localMessages) {
            const messages = JSON.parse(localMessages);
            const message = messages.find(m => m.id === messageId);
            if (message && message.timestamp) {
              element.textContent = enhancedFormatTimestamp(message.timestamp);
            }
          }
        } catch (error) {
          console.error('Error updating timestamps:', error);
        }
      }
    });
    
    // Also update reply timestamps
    const replyTimeElements = document.querySelectorAll('.reply-time');
    replyTimeElements.forEach(element => {
      // Similar logic for replies could be implemented here
    });
  }
  
  // Override the platform's timestamp formatter
  if (window.formatTimestamp) {
    window.originalFormatTimestamp = window.formatTimestamp;
  }
  window.formatTimestamp = enhancedFormatTimestamp;
  
  // Date headers functionality
  function initDateHeaders() {
    const chat = document.querySelector('.chat-container, #chatContainer, .message-list');
    if (!chat) {
      console.log('Chat container not found, retrying in 500ms');
      setTimeout(initDateHeaders, 500);
      return;
    }
    
    // Clear old headers first
    removeExistingHeaders();
    
    // Process all messages
    const messages = Array.from(chat.querySelectorAll('.message, .chat-message'));
    if (!messages.length) return;
    
    let lastDateKey = null;
    const processedDates = new Set();
    
    messages.forEach(message => {
      const timestamp = getMessageTimestamp(message);
      if (!timestamp) return;
      
      const dateKey = getDateKey(timestamp);
      if (dateKey !== lastDateKey && !processedDates.has(dateKey)) {
        const header = createHeaderElement(getDisplayText(timestamp));
        message.parentNode.insertBefore(header, message);
        
        processedDates.add(dateKey);
        lastDateKey = dateKey;
      }
    });
  }
  
  function getMessageTimestamp(message) {
    try {
      // Try getting timestamp from localStorage first (your preferred method)
      const messageId = message.getAttribute('data-message-id');
      if (messageId) {
        try {
          const localMessages = localStorage.getItem('localMessages');
          if (localMessages) {
            const messages = JSON.parse(localMessages);
            const messageObj = messages.find(m => m.id === messageId);
            if (messageObj && messageObj.timestamp) {
              return new Date(messageObj.timestamp);
            }
          }
        } catch (e) {
          console.error('Error accessing localStorage:', e);
        }
      }
      
      // Fallback methods
      // 1. Check for direct timestamp data
      if (message.dataset.timestamp) {
        return new Date(parseInt(message.dataset.timestamp) || message.dataset.timestamp);
      }
      
      // 2. Check time element data
      const timeElement = message.querySelector('.message-time, .timestamp');
      if (timeElement?.dataset.timestamp) {
        return new Date(parseInt(timeElement.dataset.timestamp) || timeElement.dataset.timestamp);
      }
      
      // 3. Parse from visible time text as last resort
      if (timeElement?.textContent) {
        return parseTimeText(timeElement.textContent.trim());
      }
      
      return null;
    } catch (e) {
      console.error('Failed to parse timestamp:', e);
      return null;
    }
  }
  
  function parseTimeText(timeText) {
    // Handle various timestamp text formats
    
    // Format: "Today at 10:30"
    if (timeText.includes('Today at')) {
      const time = timeText.split('at')[1].trim();
      const [hours, minutes] = time.split(':').map(Number);
      const now = new Date();
      return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
    }
    
    // Format: "Yesterday at 10:30"
    if (timeText.includes('Yesterday at')) {
      const time = timeText.split('at')[1].trim();
      const [hours, minutes] = time.split(':').map(Number);
      const now = new Date();
      now.setDate(now.getDate() - 1);
      return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
    }
    
    // Format: "Monday at 10:30" (day of week)
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    for (const day of days) {
      if (timeText.includes(`${day} at`)) {
        const time = timeText.split('at')[1].trim();
        const [hours, minutes] = time.split(':').map(Number);
        
        const now = new Date();
        const currentDay = now.getDay(); // 0-6
        const targetDay = days.indexOf(day); // 0-6
        
        let daysToSubtract = currentDay - targetDay;
        if (daysToSubtract < 0) daysToSubtract += 7;
        
        now.setDate(now.getDate() - daysToSubtract);
        return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
      }
    }
    
    // Format: "HH:MM" (assume today)
    if (/^\d{1,2}:\d{2}(?: [AP]M)?$/.test(timeText)) {
      const now = new Date();
      let [hours, minutesPart] = timeText.split(':');
      let minutes = parseInt(minutesPart);
      
      hours = parseInt(hours);
      
      // Handle AM/PM if present
      if (minutesPart.includes('PM') && hours < 12) {
        hours += 12;
      } else if (minutesPart.includes('AM') && hours === 12) {
        hours = 0;
      }
      
      return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
    }
    
    // Last resort: Try direct parse
    return new Date(timeText);
  }
  
  function getDateKey(date) {
    return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
  }
  
  function getDisplayText(date) {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const dayDiff = Math.floor((today - messageDate) / (1000 * 60 * 60 * 24));
    
    if (dayDiff === 0) return "Today";
    if (dayDiff === 1) return "Yesterday";
    if (dayDiff < 7) return date.toLocaleDateString(undefined, { weekday: 'long' });
    if (messageDate.getFullYear() === today.getFullYear()) {
      return date.toLocaleDateString(undefined, { month: 'long', day: 'numeric' });
    }
    return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
  }
  
  function createHeaderElement(text) {
    const header = document.createElement('div');
    header.className = 'date-header';
    
    const label = document.createElement('div');
    label.className = 'date-label';
    label.textContent = text;
    
    // Glass morphism styling
    label.style.display = 'inline-block';
    label.style.padding = '6px 18px';
    label.style.borderRadius = '20px';
    label.style.fontSize = '13px';
    label.style.fontWeight = '500';
    label.style.color = '#fff';
    label.style.textShadow = '0 1px 2px rgba(0,0,0,0.2)';
    label.style.background = HEADER_GRADIENT;
    label.style.border = '1px solid rgba(255,255,255,0.15)';
    label.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
    label.style.backdropFilter = 'blur(0px)'; // Ensure it's not blurry
    
    header.appendChild(label);
    return header;
  }
  
  function removeExistingHeaders() {
    document.querySelectorAll('.date-header').forEach(el => el.remove());
  }
  
  function setupMutationObserver() {
    const observer = new MutationObserver(mutations => {
      if (mutations.some(m => m.addedNodes.length > 0)) {
        setTimeout(() => {
          initDateHeaders();
          updateAllTimestamps();
        }, 50);
      }
    });
    
    const chat = document.querySelector('.chat-container, #chatContainer, .message-list');
    if (chat) {
      observer.observe(chat, { childList: true, subtree: true });
    } else {
      setTimeout(setupMutationObserver, 500);
    }
  }
  
  function addGlobalStyles() {
    if (document.getElementById('date-header-styles')) return;
    
    const style = document.createElement('style');
    style.id = 'date-header-styles';
    style.textContent = `
      .date-header {
        text-align: center;
        margin: 16px 0;
        position: relative;
        z-index: 10;
      }
      .date-header:first-child {
        margin-top: 8px;
      }
    `;
    document.head.appendChild(style);
  }
  
  // Initialize everything
  function init() {
    addGlobalStyles();
    
    function initialRun() {
      initDateHeaders();
      updateAllTimestamps();
      setupMutationObserver();
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(initialRun, 300);
      });
    } else {
      setTimeout(initialRun, 300);
    }
    
    // Periodically refresh timestamps and headers
    setInterval(() => {
      updateAllTimestamps();
      initDateHeaders();
    }, 60000);
  }
  
  init();
})();

</script>

<script>
// Create and append styles
const styleSheet = document.createElement('style');
styleSheet.textContent = `
.media-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.media-modal.active {
    opacity: 1;
    pointer-events: all;
}

.media-container {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}

.media-content {
    position: relative;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: grab;
    max-width: 95%;
    max-height: 80%;
}

.media-content.dragging {
    cursor: grabbing;
    transition: none;
}

.media-content img,
.media-content video {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 8px;
}

.video-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
    padding: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 10;
}

.media-content:hover .video-controls {
    opacity: 1;
}

.video-progress {
    flex-grow: 1;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    cursor: pointer;
    position: relative;
}

.video-progress-bar {
    height: 100%;
    background: #1DA1F2; /* Twitter blue */
    border-radius: 2px;
    position: absolute;
    top: 0;
    left: 0;
    transition: width 0.1s linear;
}

.video-button {
    background: none;
    border: none;
    color: white;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.video-button:hover {
    transform: scale(1.1);
}

.video-button svg {
    width: 24px;
    height: 24px;
}

.video-time {
    color: white;
    font-size: 14px;
    font-family: monospace;
}

.media-reactions {
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 10px;
    padding: 15px;
    margin-top: 15px;
}

.media-text {
    color: white;
    max-width: 80%;
    margin-top: 15px;
    font-size: 16px;
    line-height: 1.5;
    text-align: center;
    padding: 10px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(5px);
}

.reaction-item {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(8px);
    padding: 8px 16px;
    border-radius: 20px;
    color: white;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 6px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    animation: fadeInUp 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    opacity: 0;
    cursor: pointer;
    transition: transform 0.2s ease, background-color 0.2s ease;
}

.reaction-item:hover {
    transform: translateY(-3px);
    background: rgba(255, 255, 255, 0.3);
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.reaction-icon {
    width: 18px;
    height: 18px;
    fill: currentColor;
}

.reaction-count {
    color: rgba(255, 255, 255, 0.9);
}

.drag-indicator {
    width: 40px;
    height: 5px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 3px;
    margin-bottom: 20px;
}

@media (max-width: 768px) {
    .media-reactions {
        overflow-x: auto;
        justify-content: flex-start;
        padding: 10px 20px;
        -webkit-overflow-scrolling: touch;
        scroll-snap-type: x mandatory;
    }
    
    .reaction-item {
        scroll-snap-align: start;
        flex-shrink: 0;
    }
}
`;
document.head.appendChild(styleSheet);

// Create modal HTML
const modal = document.createElement('div');
modal.className = 'media-modal';
modal.innerHTML = `
    <div class="media-container">
        <div class="drag-indicator"></div>
        <div class="media-content">
            <div class="video-controls">
                <button class="video-button play-pause">
                    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M8 5v14l11-7z"/></svg>
                </button>
                <div class="video-progress">
                    <div class="video-progress-bar"></div>
                </div>
                <span class="video-time">0:00 / 0:00</span>
                <button class="video-button volume">
                    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                </button>
            </div>
        </div>
        <div class="media-text"></div>
        <div class="media-reactions"></div>
    </div>
`;
document.body.appendChild(modal);

// Variables for handling interactions
let startY = 0;
let currentY = 0;
let startX = 0;
let currentX = 0;
let isDragging = false;
let originalRect = null;
let sourceElement = null;
let currentVideo = null;
let sourcePost = null;

function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    seconds = Math.floor(seconds % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function setupVideoControls(video) {
    const controls = modal.querySelector('.video-controls');
    const playPauseBtn = controls.querySelector('.play-pause');
    const progressBar = controls.querySelector('.video-progress-bar');
    const progress = controls.querySelector('.video-progress');
    const timeDisplay = controls.querySelector('.video-time');
    const volumeBtn = controls.querySelector('.volume');

    // Update play/pause button
    function updatePlayButton() {
        playPauseBtn.innerHTML = video.paused ? 
            '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M8 5v14l11-7z"/></svg>' :
            '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
    }

    // Play/Pause toggle
    playPauseBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (video.paused) video.play();
        else video.pause();
    });

    // Progress bar updates
    video.addEventListener('timeupdate', () => {
        const progress = (video.currentTime / video.duration) * 100;
        progressBar.style.width = `${progress}%`;
        timeDisplay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
    });

    // Click to seek
    progress.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = progress.getBoundingClientRect();
        const pos = (e.clientX - rect.left) / rect.width;
        video.currentTime = pos * video.duration;
    });

    // Volume toggle
    volumeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        video.muted = !video.muted;
        volumeBtn.innerHTML = video.muted ?
            '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>' :
            '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>';
    });

    // Event listeners for play/pause updates
    video.addEventListener('play', updatePlayButton);
    video.addEventListener('pause', updatePlayButton);
}

function showMedia(element, info) {
    sourceElement = element;
    sourcePost = info.post;
    originalRect = element.getBoundingClientRect();
    const modalContent = modal.querySelector('.media-content');
    const mediaText = modal.querySelector('.media-text');
    
    // Clone media and hide original
    const clone = element.cloneNode(true);
    sourceElement.style.visibility = 'hidden';
    
    if (clone.tagName === 'VIDEO') {
        clone.controls = false;
        clone.muted = false;
        clone.playsInline = true;
        clone.autoplay = true;
        
        modalContent.innerHTML = `
            <div class="video-controls">
                <button class="video-button play-pause">
                    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M8 5v14l11-7z"/></svg>
                </button>
                <div class="video-progress">
                    <div class="video-progress-bar"></div>
                </div>
                <span class="video-time">0:00 / 0:00</span>
                <button class="video-button volume">
                    <svg viewBox="0 0 24 24"><path fill="currentColor" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                </button>
            </div>
        `;
        modalContent.appendChild(clone);
        currentVideo = clone;
        setupVideoControls(clone);
    } else {
        modalContent.innerHTML = '';
        modalContent.appendChild(clone);
    }

    // Display text if available
    const postTextElement = info.post.querySelector('.text-content');
    if (postTextElement && postTextElement.textContent.trim()) {
        mediaText.textContent = postTextElement.textContent;
        mediaText.style.display = 'block';
    } else {
        mediaText.style.display = 'none';
    }

    // Set initial position
    modalContent.style.width = `${originalRect.width}px`;
    modalContent.style.height = `${originalRect.height}px`;
    modalContent.style.transform = `translate(${originalRect.left - window.innerWidth/2 + originalRect.width/2}px, ${originalRect.top - window.innerHeight/2 + originalRect.height/2}px)`;

    // Lock body scroll
    document.body.style.overflow = 'hidden';

    // Show modal
    modal.classList.add('active');

    // Animate to center
    requestAnimationFrame(() => {
        modalContent.style.width = '';
        modalContent.style.height = '';
        modalContent.style.transform = 'translate(0, 0)';
    });

    // Update reactions with actual reaction elements from the post
    const mediaReactions = modal.querySelector('.media-reactions');
    mediaReactions.innerHTML = '';
    
    const originalReactions = Array.from(info.post.querySelectorAll('.reaction'));
    originalReactions.forEach((reaction, index) => {
        const clonedReaction = reaction.cloneNode(true);
        clonedReaction.className = 'reaction-item';
        clonedReaction.style.animationDelay = `${index * 0.1}s`;
        
        // Preserve the click functionality
        clonedReaction.addEventListener('click', (e) => {
            e.stopPropagation();
            // Find and click the original reaction to trigger the same action
            reaction.click();
            
            // Update the reaction count locally for immediate feedback
            const count = reaction.querySelector('.reaction-count');
            if (count) {
                clonedReaction.querySelector('.reaction-count').textContent = count.textContent;
            }
        });
        
        mediaReactions.appendChild(clonedReaction);
    });
    
    // Add the "add reaction" button
    const addReactionBtn = info.post.querySelector('.add-reaction');
    if (addReactionBtn) {
        const clonedAddBtn = addReactionBtn.cloneNode(true);
        clonedAddBtn.className = 'reaction-item';
        clonedAddBtn.style.animationDelay = `${originalReactions.length * 0.1}s`;
        
        clonedAddBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            addReactionBtn.click();
        });
        
        mediaReactions.appendChild(clonedAddBtn);
    }
}

// Touch and mouse event handlers
function handleStart(e) {
    if (e.target.closest('.video-controls') || e.target.closest('.reaction-item')) {
        return; // Don't initiate drag if clicking controls or reactions
    }
    
    const touch = e.touches ? e.touches[0] : e;
    startY = touch.clientY;
    startX = touch.clientX;
    isDragging = true;
    modal.querySelector('.media-content').classList.add('dragging');
    
    // Prevent default only for mouse to avoid text selection
    if (!e.touches) {
        e.preventDefault();
    }
}

function handleMove(e) {
    if (!isDragging) return;
    
    // Prevent default to stop scrolling while dragging
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    currentY = touch.clientY;
    currentX = touch.clientX;
    
    const deltaY = currentY - startY;
    const deltaX = currentX - startX;
    const rotation = deltaX * 0.05; // Reduced rotation effect
    
    const content = modal.querySelector('.media-content');
    const scale = Math.max(0.6, 1 - (Math.abs(deltaY) / window.innerHeight) * 0.4);
    const opacity = 1 - (Math.abs(deltaY) / window.innerHeight) * 0.8;
    
    modal.style.background = `rgba(0, 0, 0, ${Math.max(0.1, opacity * 0.95)})`;
    content.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${scale}) rotate(${rotation}deg)`;
    
    // Also update visibility of other elements
    const text = modal.querySelector('.media-text');
    const reactions = modal.querySelector('.media-reactions');
    if (text) text.style.opacity = opacity;
    if (reactions) reactions.style.opacity = opacity;
}

function handleEnd(e) {
    if (!isDragging) return;
    
    const deltaY = currentY - startY;
    const content = modal.querySelector('.media-content');
    content.classList.remove('dragging');
    content.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    
    // Also reset transition for other elements
    const text = modal.querySelector('.media-text');
    const reactions = modal.querySelector('.media-reactions');
    if (text) text.style.transition = 'opacity 0.3s ease';
    if (reactions) reactions.style.transition = 'opacity 0.3s ease';
    
    // Close if dragged far enough
    if (Math.abs(deltaY) > window.innerHeight / 5) {
        closeModal();
    } else {
        // Spring back animation
        modal.style.background = '';
        content.style.transform = '';
        if (text) text.style.opacity = '';
        if (reactions) reactions.style.opacity = '';
    }
    isDragging = false;
}

function closeModal() {
    const content = modal.querySelector('.media-content');
    const text = modal.querySelector('.media-text');
    const reactions = modal.querySelector('.media-reactions');
    
    // Animate back to original position
    content.style.transform = `
        translate(${originalRect.left - window.innerWidth/2 + originalRect.width/2}px, 
                 ${originalRect.top - window.innerHeight/2 + originalRect.height/2}px) 
        scale(${originalRect.width / content.offsetWidth})
    `;
    modal.style.background = 'rgba(0, 0, 0, 0)';
    
    // Fade out other elements
    if (text) text.style.opacity = '0';
    if (reactions) reactions.style.opacity = '0';
    
    setTimeout(() => {
        modal.classList.remove('active');
        content.innerHTML = '';
        text.textContent = '';
        reactions.innerHTML = '';
        
        if (sourceElement) {
            sourceElement.style.visibility = 'visible';
            sourceElement = null;
        }
        if (currentVideo) {
            currentVideo.pause();
            currentVideo = null;
        }
        
        document.body.style.overflow = '';
        sourcePost = null;
    }, 300);
}

// Event listeners using passive option for better performance
modal.addEventListener('mousedown', handleStart, { passive: false });
modal.addEventListener('touchstart', handleStart, { passive: true });
modal.addEventListener('mousemove', handleMove, { passive: false });
modal.addEventListener('touchmove', handleMove, { passive: false });
modal.addEventListener('mouseup', handleEnd, { passive: true });
modal.addEventListener('touchend', handleEnd, { passive: true });
modal.addEventListener('mouseleave', handleEnd, { passive: true });

// Handle media clicks - use capturing to get events early
document.addEventListener('click', (e) => {
    const mediaElement = e.target.closest('.post-media');
    if (!mediaElement) return;
    
    const post = mediaElement.closest('.message');
    if (!post) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    showMedia(mediaElement, { post });
}, { capture: true });

// Close on escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && modal.classList.contains('active')) {
        closeModal();
    }
});

// Prevent conflicts by using unique class names and contained scope
(function() {
    // Additional initialization if needed
})();
</script>


</body>
</html>

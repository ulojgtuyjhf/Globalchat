
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Chat Gallery</title>
    
    <style>
    
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: #ffffff;
    color: #0f1419;
    transition: background-color 0.3s ease, color 0.3s ease;
}

.chat-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 0 60px 0;
    display: flex;
    flex-direction: column;
    height: calc(100vh - 60px);
    overflow-y: auto;
    scroll-behavior: smooth;
}

.message {
    display: flex;
    padding: 12px 16px;
    margin-bottom: 12px;
    align-items: flex-start;
    opacity: 0;
    transform: translateY(10px);
    animation: messageAppear 0.3s ease forwards;
    position: relative;
}

@keyframes messageAppear {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message:hover {
    background-color: rgba(0, 0, 0, 0.02);
    transition: background-color 0.2s ease;
}

.profile-pic {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
    flex-shrink: 0;
    object-fit: cover;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: transform 0.2s ease;
}

.message:hover .profile-pic {
    transform: scale(1.05);
}

.message-bubble {
    background-color: #f7f9fa;
    border-radius: 16px;
    padding: 14px;
    max-width: calc(100% - 60px);
    position: relative;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: box-shadow 0.2s ease, transform 0.2s ease;
}

@media (min-width: 768px) {
    .message-bubble {
        max-width: 60%;
    }
}

.message-header {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
}

.username {
    font-weight: 700;
    color: #0f1419;
    font-size: 15px;
    margin-right: 8px;
    transition: color 0.2s ease;
}

.status-indicator {
    width: 10px;
    height: 10px;
    margin-right: 6px;
    border-radius: 50%;
    background-color: #1da1f2;
    box-shadow: 0 0 0 rgba(29, 161, 242, 0.4);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(29, 161, 242, 0.4);
    }
    70% {
        box-shadow: 0 0 0 6px rgba(29, 161, 242, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(29, 161, 242, 0);
    }
}

.text-content {
    line-height: 1.4;
    margin-bottom: 8px;
}

.media-wrapper {
    width: 100%;
    max-width: 100%;
    margin: 10px 0;
    border-radius: 14px;
    overflow: hidden;
    background: #f7f9fa;
    position: relative;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: transform 0.3s ease;
}

.media-wrapper.media-loading::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 3px solid rgba(29, 161, 242, 0.1);
    border-top-color: #1da1f2;
    transform: translate(-50%, -50%);
    animation: spin 1s linear infinite;
}

.media-wrapper.media-loading {
    min-height: 200px;
}

.media-wrapper:hover {
    transform: scale(1.01);
}

.post-media {
    width: 100%;
    max-width: 100%;
    display: block;
    border-radius: 14px;
    transition: filter 0.3s ease;
}

.post-video {
    max-height: 80vh;
    background: #000;
}

.reactions-container {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 0, 0, 0.08);
}

.reaction {
    background: #ffffff;
    border-radius: 14px;
    padding: 2px 8px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 3px;
    cursor: pointer;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: all 0.2s ease;
}

.reaction:hover {
    background: #f0f3f5;
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.reaction.user-reacted {
    background: rgba(29, 161, 242, 0.1);
    color: #1da1f2;
    border-color: rgba(29, 161, 242, 0.2);
}

.reaction.user-reacted:hover {
    background: rgba(29, 161, 242, 0.15);
}

.loading-spinner {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 20px 0;
    height: 40px;
}

.spinner-inner {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid rgba(29, 161, 242, 0.1);
    border-top-color: #1da1f2;
    animation: spin 0.8s cubic-bezier(0.5, 0.1, 0.4, 0.9) infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

.emoji-picker {
    position: absolute;
    bottom: 100%;
    left: 0;
    background: #ffffff;
    border-radius: 16px;
    padding: 8px;
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 4px;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
    z-index: 1000;
    border: 1px solid rgba(0, 0, 0, 0.08);
    animation: slideUp 0.2s ease;
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.emoji-option {
    cursor: pointer;
    padding: 6px;
    border-radius: 6px;
    text-align: center;
    transition: all 0.2s ease;
    font-size: 16px;
    line-height: 1;
}

.emoji-option:hover {
    background: #f0f3f5;
    transform: scale(1.1);
}

.add-reaction {
    padding: 2px 8px;
    cursor: pointer;
    border-radius: 14px;
    background: #ffffff;
    border: 1px solid rgba(0, 0, 0, 0.08);
    transition: all 0.2s ease;
    position: relative;
    font-size: 14px;
}

.add-reaction:hover {
    background: #f0f3f5;
    transform: scale(1.1);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.timestamp {
    color: #657786;
    font-size: 13px;
    margin-left: auto;
    transition: color 0.2s ease;
}

/* Dark mode styles */
body.theme-dark {
    background-color: #000000;
    color: #ffffff;
}

body.theme-dark .message-bubble {
    background-color: #16181c;
    border-color: #2f3336;
}

body.theme-dark .reaction {
    background: #16181c;
    border-color: #2f3336;
    color: #e6e9ea;
}

body.theme-dark .reaction:hover {
    background: #1d2023;
}

body.theme-dark .reaction.user-reacted {
    background: rgba(29, 161, 242, 0.2);
    color: #1da1f2;
}

body.theme-dark .username {
    color: #ffffff;
}

body.theme-dark .timestamp {
    color: #8899a6;
}

body.theme-dark .media-wrapper {
    background: #16181c;
    border-color: #2f3336;
}

body.theme-dark .add-reaction {
    background: #16181c;
    border-color: #2f3336;
}

body.theme-dark .add-reaction:hover {
    background: #1d2023;
}

body.theme-dark .emoji-picker {
    background: #16181c;
    border-color: #2f3336;
}

body.theme-dark .emoji-option:hover {
    background: #1d2023;
}

/* Dim mode styles */
body.theme-dim {
    background-color: #15202b;
    color: #ffffff;
}

body.theme-dim .message-bubble {
    background-color: #192734;
    border-color: #38444d;
}

body.theme-dim .reaction {
    background: #192734;
    border-color: #38444d;
    color: #e6e9ea;
}

body.theme-dim .reaction:hover {
    background: #1e2c3a;
}

body.theme-dim .reaction.user-reacted {
    background: rgba(29, 161, 242, 0.2);
    color: #1da1f2;
}

body.theme-dim .username {
    color: #ffffff;
}

body.theme-dim .timestamp {
    color: #8899a6;
}

body.theme-dim .media-wrapper {
    background: #192734;
    border-color: #38444d;
}

body.theme-dim .add-reaction {
    background: #192734;
    border-color: #38444d;
}

body.theme-dim .add-reaction:hover {
    background: #1e2c3a;
}

body.theme-dim .emoji-picker {
    background: #192734;
    border-color: #38444d;
}

body.theme-dim .emoji-option:hover {
    background: #1e2c3a;
}

/* Message animation variations */
.message:nth-child(3n+1) {
    animation-delay: 0.05s;
}

.message:nth-child(3n+2) {
    animation-delay: 0.1s;
}

.message:nth-child(3n+3) {
    animation-delay: 0.15s;
}

/* Error message styling */
.error {
    padding: 16px;
    margin: 20px auto;
    border-radius: 16px;
    background-color: rgba(224, 36, 94, 0.1);
    color: #e0245e;
    text-align: center;
    max-width: 80%;
    border: 1px solid rgba(224, 36, 94, 0.2);
    animation: fadeIn 0.3s ease;
}

body.theme-dark .error, 
body.theme-dim .error {
    background-color: rgba(224, 36, 94, 0.2);
    color: #f4a5be;
}

/* Follow button styles */
.follow-btn {
    background-color: transparent;
    color: #626262;
    border: 1px solid #626262;
    border-radius: 9999px;
    padding: 3px 12px;
    font-weight: 600;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.25s cubic-bezier(0.2, 0, 0, 1);
    position: relative;
    overflow: hidden;
    min-width: 70px;
    margin-left: auto;
}

.follow-btn.followed {
    background: linear-gradient(
        135deg,  
        #0f0f0f 0%,  
        #1c1c1c 15%,  
        #3a3a3a 30%,  
        #4d4d4d 45%,  
        #626262 60%,  
        #787878 75%,  
        #8f8f8f 90%,  
        #a6a6a6 100%
    );
    color: white;
    border: 1px solid transparent;
}

.follow-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
}

.follow-btn:active {
    transform: translateY(0px);
}

.follow-btn .loading-spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid rgba(98, 98, 98, 0.1);
    border-radius: 50%;
    border-top-color: #626262;
    animation: spin 0.8s cubic-bezier(0.5, 0.1, 0.4, 0.9) infinite;
    margin: 0;
}

.follow-btn.followed .loading-spinner {
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-top-color: #ffffff;
}

.user-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
}

.user-info {
    display: flex;
    align-items: center;
}

/* Responsive improvements */
@media (max-width: 480px) {
    .follow-btn {
        padding: 2px 8px;
        font-size: 11px;
        min-width: 60px;
    }
    
    .reaction {
        padding: 1px 6px;
        font-size: 11px;
    }
    
    .emoji-picker {
        grid-template-columns: repeat(5, 1fr);
    }
}

    </style>
</head>
<body>
    <div class="chat-container" id="chat-container"></div>
    <div class="header-space"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, limit, getDocs, doc, getDoc, updateDoc, arrayUnion, arrayRemove, onSnapshot, startAfter, where, addDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDnPz8BWCaXJOazlFVO4Eap8VxdSR2oDFQ",
            authDomain: "globalchat-2d669.firebaseapp.com",
            projectId: "globalchat-2d669",
            storageBucket: "globalchat-2d669.firebasestorage.app",
            messagingSenderId: "178714711978",
            appId: "1:178714711978:web:fb831188be23e62a4bbdd3"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const MESSAGES_PER_PAGE = 20;
        let lastVisible = null;
        let loading = false;
        let realtimeUnsubscribe = null;
        let hasMoreMessages = true;

        const commonEmojis = ['👍', '❤️', '😂', '😮', '😢', '🙏'];

        // Intersection Observer for media loading
        const mediaObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const mediaWrapper = entry.target;
                    const mediaElement = mediaWrapper.querySelector('img, video');
                    
                    if (mediaElement && mediaElement.dataset.src) {
                        mediaElement.src = mediaElement.dataset.src;
                        mediaElement.onload = () => {
                            mediaWrapper.classList.remove('media-loading');
                        };
                        mediaElement.onerror = () => {
                            mediaWrapper.classList.remove('media-loading');
                            mediaWrapper.classList.add('media-error');
                        };
                        mediaObserver.unobserve(mediaWrapper);
                    }
                }
            });
        }, {
            rootMargin: '100px',
            threshold: 0.1
        });

        // Scroll Observer for Infinite Loading
        const scrollObserver = new IntersectionObserver((entries) => {
            const lastEntry = entries[0];
            if (lastEntry.isIntersecting && hasMoreMessages && !loading) {
                loadMessages(false);
            }
        }, {
            rootMargin: '200px',
            threshold: 0.1
        });

        async function getUserProfile(userId) {
            try {
                const userDocRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userDocRef);
                return userDoc.exists() ? userDoc.data() : null;
            } catch (error) {
                console.error('Error fetching user profile:', error);
                return null;
            }
        }

        async function isFollowing(currentUserId, targetUserId) {
            try {
                const followQuery = query(
                    collection(db, 'follows'),
                    where('followerUserId', '==', currentUserId),
                    where('followedUserId', '==', targetUserId)
                );
                
                const followSnapshot = await getDocs(followQuery);
                return !followSnapshot.empty;
            } catch (error) {
                console.error('Error checking follow status:', error);
                return false;
            }
        }

        async function toggleFollow(userId, userName, button) {
            const currentUser = auth.currentUser;
            
            if (!currentUser) {
                alert('Please log in to follow users');
                return;
            }

            try {
                // Show loading state on button
                button.disabled = true;
                button.innerHTML = '<span class="loading-spinner"></span>';

                // Check if follow relationship already exists
                const followQuery = query(
                    collection(db, 'follows'),
                    where('followerUserId', '==', currentUser.uid),
                    where('followedUserId', '==', userId)
                );
                
                const followSnapshot = await getDocs(followQuery);

                if (followSnapshot.empty) {
                    // Follow the user - create a new follow record
                    await addDoc(collection(db, 'follows'), {
                        followerUserId: currentUser.uid,
                        followedUserId: userId,
                        followedUserName: userName,
                        timestamp: new Date()
                    });
                    
                    // Update button to "Following" state after success
                    setTimeout(() => {
                        button.innerHTML = 'Following';
                        button.classList.add('followed');
                        button.disabled = false;
                    }, 500);
                } else {
                    // Unfollow the user - delete the existing follow record(s)
                    followSnapshot.forEach(async (doc) => {
                        await deleteDoc(doc.ref);
                    });
                    
                    // Update button back to "Follow" state after success
                    setTimeout(() => {
                        button.innerHTML = 'Follow';
                        button.classList.remove('followed');
                        button.disabled = false;
                    }, 500);
                }
            } catch (error) {
                console.error('Follow/Unfollow error:', error);
                // Reset button to original state on error
                button.disabled = false;
                button.innerHTML = 'Follow';
                button.classList.remove('followed');
            }
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            return date.toLocaleDateString();
        }

        async function toggleReaction(postId, emoji, userId) {
            try {
                const postRef = doc(db, 'posts', postId);
                const postDoc = await getDoc(postRef);
                
                if (!postDoc.exists()) return;
                
                const reactions = postDoc.data().reactions || {};
                const reactionUsers = reactions[emoji] || [];
                
                if (reactionUsers.includes(userId)) {
                    await updateDoc(postRef, {
                        [`reactions.${emoji}`]: arrayRemove(userId)
                    });
                } else {
                    await updateDoc(postRef, {
                        [`reactions.${emoji}`]: arrayUnion(userId)
                    });
                }
            } catch (error) {
                console.error('Error toggling reaction:', error);
            }
        }

        function createEmojiPicker(postId, userId) {
            const picker = document.createElement('div');
            picker.className = 'emoji-picker';
            
            commonEmojis.forEach(emoji => {
                const option = document.createElement('div');
                option.className = 'emoji-option';
                option.textContent = emoji;
                option.onclick = (e) => {
                    e.stopPropagation();
                    toggleReaction(postId, emoji, userId);
                    picker.remove();
                };
                picker.appendChild(option);
            });
            
            return picker;
        }

        function renderReactions(reactions = {}, postId, userId) {
            const container = document.createElement('div');
            container.className = 'reactions-container';
            
            Object.entries(reactions).forEach(([emoji, users]) => {
                if (users.length > 0) {
                    const reaction = document.createElement('div');
                    reaction.className = 'reaction';
                    reaction.classList.toggle('user-reacted', users.includes(userId));
                    reaction.innerHTML = `
                        ${emoji}
                        <span class="reaction-count">${users.length}</span>
                    `;
                    reaction.onclick = () => toggleReaction(postId, emoji, userId);
                    container.appendChild(reaction);
                }
            });
            
            const addReaction = document.createElement('div');
            addReaction.className = 'add-reaction';
            addReaction.innerHTML = '😊';
            addReaction.onclick = (e) => {
                e.stopPropagation();
                const existing = document.querySelector('.emoji-picker');
                if (existing) existing.remove();
                
                const picker = createEmojiPicker(postId, userId);
                addReaction.appendChild(picker);
                
                document.addEventListener('click', () => picker.remove(), { once: true });
            };
            
            container.appendChild(addReaction);
            return container;
        }

        function createMediaElement(post) {
            if (!post.mediaUrl) return null;

            const mediaWrapper = document.createElement('div');
            mediaWrapper.className = 'media-wrapper media-loading';

            const isVideo = post.mediaType?.startsWith('video/') || post.mediaUrl?.match(/\.(mp4|webm|ogg)$/i);
            
            if (isVideo) {
                const video = document.createElement('video');
                video.className = 'post-media post-video';
                video.controls = false;
                video.preload = 'none';
                video.autoplay = true;
                video.muted = true;
                video.dataset.src = post.mediaUrl;
                video.playsInline = true;
                
                if (post.thumbnailUrl) {
                    video.poster = post.thumbnailUrl;
                }

                video.onloadeddata = () => {
                    mediaWrapper.classList.remove('media-loading');
                };

                mediaWrapper.appendChild(video);
            } else {
                const img = document.createElement('img');
                img.className = 'post-media post-image';
                img.dataset.src = post.mediaUrl;
                img.alt = "Posted image";
                
                mediaWrapper.appendChild(img);
            }

            mediaObserver.observe(mediaWrapper);
            return mediaWrapper;
        }

        async function createMessageElement(post, userId) {
            const userProfile = await getUserProfile(post.userId);
            const username = userProfile?.displayName || `User ${post.userId.slice(0, 4)}`;
            const profilePic = userProfile?.photoURL || "/api/placeholder/40/40";
            
            // Check if the current user is following this post's author
            const followingStatus = await isFollowing(userId, post.userId);

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.dataset.postId = post.id;
            messageDiv.dataset.userId = post.userId;
            
            // Create the follow button
            const followButton = document.createElement('button');
            followButton.className = 'follow-btn';
            if (followingStatus) {
                followButton.classList.add('followed');
                followButton.textContent = 'Following';
            } else {
                followButton.textContent = 'Follow';
            }
            
            // Skip follow button for current user's posts
            const showFollowButton = post.userId !== userId;
            
            const messageHeader = document.createElement('div');
            messageHeader.className = 'user-header';
            
            messageHeader.innerHTML = `
                <div class="user-info">
                    <div class="status-indicator"></div>
                    <span class="username">${username}</span>
                    <span class="timestamp">${formatTimestamp(post.createdAt)}</span>
                </div>
            `;
            
            if (showFollowButton) {
                followButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleFollow(post.userId, username, followButton);
                });
                messageHeader.appendChild(followButton);
            }
            
            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            messageBubble.appendChild(messageHeader);
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            if (post.text) {
                const textElement = document.createElement('p');
                textElement.className = 'text-content';
                textElement.textContent = post.text;
                messageContent.appendChild(textElement);
            }
            
            messageBubble.appendChild(messageContent);
            
            messageDiv.innerHTML = `<img src="${profilePic}" alt="Profile" class="profile-pic">`;
            messageDiv.appendChild(messageBubble);
            
            if (post.mediaUrl) {
                const mediaElement = createMediaElement(post);
                if (mediaElement) {
                    messageContent.appendChild(mediaElement);
                }
            }

            messageBubble.appendChild(renderReactions(post.reactions, post.id, userId));

            return messageDiv;
        }

        function updateMessage(post, userId) {
            const existingMessage = document.querySelector(`.message[data-post-id="${post.id}"]`);
            if (existingMessage) {
                const messageBubble = existingMessage.querySelector('.message-bubble');
                const oldReactions = messageBubble.querySelector('.reactions-container');
                if (oldReactions) {
                    oldReactions.replaceWith(renderReactions(post.reactions, post.id, userId));
                }
            }
        }

        function createLoadingSpinner() {
            const spinner = document.createElement('div');
            spinner.className = 'loading-spinner';
            spinner.innerHTML = `
                <div class="spinner-inner">
                    <div class="spinner-circle"></div>
                </div>
            `;
            return spinner;
        }

        async function loadMessages(initial = true) {
            if (loading || (!initial && !hasMoreMessages)) return;
            loading = true;

            const container = document.getElementById('chat-container');
            const loadingSpinner = createLoadingSpinner();
            
            if (initial) {
                container.innerHTML = '';
                container.appendChild(loadingSpinner);
                
                if (realtimeUnsubscribe) {
                    realtimeUnsubscribe();
                }
            } else {
                container.appendChild(loadingSpinner);
            }

            try {
                let messagesQuery = query(
                    collection(db, 'posts'),
                    orderBy('createdAt', 'desc'),
                    limit(MESSAGES_PER_PAGE)
                );

                if (!initial && lastVisible) {
                    messagesQuery = query(
                        collection(db, 'posts'),
                        orderBy('createdAt', 'desc'),
                        startAfter(lastVisible),
                        limit(MESSAGES_PER_PAGE)
                    );
                }

                const snapshot = await getDocs(messagesQuery);
                
                if (snapshot.empty || snapshot.docs.length < MESSAGES_PER_PAGE) {
                    hasMoreMessages = false;
                }

                if (snapshot.empty) {
                    loadingSpinner.remove();
                    loading = false;
                    return;
                }

                lastVisible = snapshot.docs[snapshot.docs.length - 1];

                if (initial) {
                    container.innerHTML = '';
                    
                    realtimeUnsubscribe = onSnapshot(
                        query(collection(db, 'posts'), orderBy('createdAt', 'desc')),
                        (snapshot) => {
                            const currentUser = auth.currentUser;
                            
                            snapshot.docChanges().forEach((change) => {
                                const post = { id: change.doc.id, ...change.doc.data() };
                                if (change.type === 'modified') {
                                    updateMessage(post, currentUser.uid);
                                }
                            });
                        }
                    );
                }

                const currentUser = auth.currentUser;
                const fragment = document.createDocumentFragment();
                
                for (const doc of snapshot.docs) {
                    const post = { id: doc.id, ...doc.data() };
                    const messageElement = await createMessageElement(post, currentUser.uid);
                    fragment.appendChild(messageElement);
                }

                loadingSpinner.remove();
                container.appendChild(fragment);

                if (hasMoreMessages) {
                    const lastMessage = container.lastElementChild;
                    if (lastMessage) {
                        scrollObserver.observe(lastMessage);
                    }
                }

            } catch (error) {
                console.error('Messages loading error:', error);
                loadingSpinner.remove();
                if (initial) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error';
                    errorDiv.textContent = 'Error loading messages';
                    container.appendChild(errorDiv);
                }
            }

            loading = false;
        }

        // Initialize the chat
        onAuthStateChanged(auth, (user) => {
            if (user) {
                loadMessages(true);
            } else {
                window.location.href = 'login.html';
            }
        });

        // Clean up
        window.addEventListener('unload', () => {
            if (realtimeUnsubscribe) {
                realtimeUnsubscribe();
            }
            mediaObserver.disconnect();
            scrollObserver.disconnect();
        });
    </script>


<script>
  (function() {
    const GlobalChatThemeManager = {
      themeConfig: {
        light: {
          '--bg-color': '#ffffff',
          '--text-primary': '#0f1419',
          '--text-secondary': '#657786',
          '--message-bubble': '#f7f9fa',
          '--border-color': 'rgba(0, 0, 0, 0.08)',
          '--message-hover': 'rgba(0, 0, 0, 0.02)',
          '--reaction-bg': '#ffffff',
          '--reaction-hover': '#f0f3f5',
          '--media-bg': '#f7f9fa',
          '--emoji-picker-bg': '#ffffff',
          '--emoji-hover': '#f0f3f5',
          '--status-indicator': '#1da1f2',
          '--profile-pic-border': 'rgba(0, 0, 0, 0.08)',
          
          // Follow button (your exact branding)
          '--follow-btn-text': '#626262',
          '--follow-btn-border': '#626262',
          '--follow-btn-hover': 'rgba(98, 98, 98, 0.08)',
          '--followed-btn-gradient': 'linear-gradient(135deg, #0f0f0f 0%, #1c1c1c 15%, #3a3a3a 30%, #4d4d4d 45%, #626262 60%, #787878 75%, #8f8f8f 90%, #a6a6a6 100%)',
          '--followed-btn-text': '#ffffff',
          '--follow-spinner': 'rgba(98, 98, 98, 0.1)',
          '--follow-spinner-top': '#626262'
        },
        dim: {
          '--bg-color': '#15202b',
          '--text-primary': '#ffffff',
          '--text-secondary': '#8899a6',
          '--message-bubble': '#192734',
          '--border-color': '#38444d',
          '--message-hover': 'rgba(29, 161, 242, 0.05)',
          '--reaction-bg': '#192734',
          '--reaction-hover': '#1e2c3a',
          '--media-bg': '#192734',
          '--emoji-picker-bg': '#192734',
          '--emoji-hover': '#1e2c3a',
          '--status-indicator': '#1da1f2',
          '--profile-pic-border': '#38444d',
          
          // Follow button (your exact branding)
          '--follow-btn-text': '#ffffff',
          '--follow-btn-border': '#8899a6',
          '--follow-btn-hover': 'rgba(136, 153, 166, 0.1)',
          '--followed-btn-gradient': 'linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 15%, #d8d8d8 30%, #c8c8c8 45%, #b8b8b8 60%, #a8a8a8 75%, #989898 90%, #888888 100%)',
          '--followed-btn-text': '#000000',
          '--follow-spinner': 'rgba(136, 153, 166, 0.1)',
          '--follow-spinner-top': '#8899a6'
        },
        dark: {
          '--bg-color': '#000000',
          '--text-primary': '#ffffff',
          '--text-secondary': '#a6a6a6',
          '--message-bubble': '#16181c',
          '--border-color': '#2f3336',
          '--message-hover': 'rgba(29, 161, 242, 0.05)',
          '--reaction-bg': '#16181c',
          '--reaction-hover': '#1d2023',
          '--media-bg': '#16181c',
          '--emoji-picker-bg': '#16181c',
          '--emoji-hover': '#1d2023',
          '--status-indicator': '#1da1f2',
          '--profile-pic-border': '#2f3336',
          
         // Follow button (your exact branding)
'--follow-btn-text': '#ffffff',
'--follow-btn-border': '#8899a6',
'--follow-btn-hover': 'rgba(136, 153, 166, 0.1)',
'--followed-btn-gradient': 'linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 15%, #d8d8d8 30%, #c8c8c8 45%, #b8b8b8 60%, #a8a8a8 75%, #989898 90%, #888888 100%)',
'--followed-btn-text': '#000000',
'--follow-spinner': 'rgba(136, 153, 166, 0.1)',
'--follow-spinner-top': '#8899a6'
}
      },
      
      styleElementId: 'global-chat-theme-styles',
      currentTheme: 'light',
      
      initialize: function() {
        this.createStyleElement();
        this.currentTheme = localStorage.getItem('twitter-theme') || 'light';
        this.applyTheme(this.currentTheme);
        this.setupEventListeners();
      },
      
      createStyleElement: function() {
        const existingStyle = document.getElementById(this.styleElementId);
        if (existingStyle) existingStyle.remove();
        
        const styleElement = document.createElement('style');
        styleElement.id = this.styleElementId;
        document.head.appendChild(styleElement);
      },
      
      applyTheme: function(themeName) {
        const theme = this.themeConfig[themeName] || this.themeConfig.light;
        this.currentTheme = themeName;
        localStorage.setItem('twitter-theme', themeName);
        
        const styleElement = document.getElementById(this.styleElementId);
        if (!styleElement) {
          this.createStyleElement();
          return this.applyTheme(themeName);
        }
        
        // Generate CSS variables
        let css = ':root {';
        for (const [key, value] of Object.entries(theme)) {
          css += `${key}: ${value};`;
        }
        css += '}';
        
        // Add comprehensive component styles
        css += `
          body {
            background-color: var(--bg-color);
            color: var(--text-primary);
          }
          
          .message-bubble {
            background-color: var(--message-bubble);
            border-color: var(--border-color);
          }
          
          .message:hover {
            background-color: var(--message-hover);
          }
          
          .reaction {
            background-color: var(--reaction-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
          }
          
          .reaction:hover {
            background-color: var(--reaction-hover);
          }
          
          .reaction.user-reacted {
            background: rgba(29, 161, 242, 0.1);
            color: #1da1f2;
            border-color: rgba(29, 161, 242, 0.2);
          }
          
          .media-wrapper {
            background-color: var(--media-bg);
            border-color: var(--border-color);
          }
          
          .username, .text-content {
            color: var(--text-primary);
          }
          
          .timestamp {
            color: var(--text-secondary);
          }
          
          .status-indicator {
            background-color: var(--status-indicator);
            box-shadow: 0 0 0 rgba(29, 161, 242, 0.4);
          }
          
          .profile-pic {
            border-color: var(--profile-pic-border);
          }
          
          .emoji-picker {
            background-color: var(--emoji-picker-bg);
            border-color: var(--border-color);
          }
          
          .emoji-option:hover {
            background-color: var(--emoji-hover);
          }
          
          /* Follow button styles - your exact branding */
          .follow-btn {
            background-color: transparent;
            color: var(--follow-btn-text);
            border: 1px solid var(--follow-btn-border);
          }
          
          .follow-btn:hover {
            background-color: var(--follow-btn-hover);
          }
          
          .follow-btn.followed {
            background: var(--followed-btn-gradient);
            color: var(--followed-btn-text);
            border: 1px solid transparent;
          }
          
          .follow-btn .loading-spinner {
            border: 2px solid var(--follow-spinner);
            border-top-color: var(--follow-spinner-top);
          }
          
          .follow-btn.followed .loading-spinner {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top-color: #ffffff;
          }
        `;
        
        styleElement.textContent = css;
        
        // Add theme class to body
        document.body.className = `theme-${themeName}`;
      },
      
      setupEventListeners: function() {
        window.addEventListener('storage', (e) => {
          if (e.key === 'twitter-theme') {
            this.applyTheme(e.newValue || 'light');
          }
        });
        
        // Setup periodic check for theme changes
        setInterval(() => {
          const storedTheme = localStorage.getItem('twitter-theme') || 'light';
          if (storedTheme !== this.currentTheme) {
            this.applyTheme(storedTheme);
          }
        }, 1000);
      }
    };
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => GlobalChatThemeManager.initialize());
    } else {
      GlobalChatThemeManager.initialize();
    }
  })();
</script>

  <script>


(function() {
  // Search Page Profile Placeholder Generator
  const SearchProfilePlaceholderGenerator = {
    // Color palette based on first letter (26 colors for 26 letters)
    letterColors: {
      'a': '#F44336', 'b': '#E91E63', 'c': '#9C27B0', 'd': '#673AB7',
      'e': '#3F51B5', 'f': '#2196F3', 'g': '#03A9F4', 'h': '#00BCD4',
      'i': '#009688', 'j': '#4CAF50', 'k': '#8BC34A', 'l': '#CDDC39',
      'm': '#FFEB3B', 'n': '#FFC107', 'o': '#FF9800', 'p': '#FF5722',
      'q': '#795548', 'r': '#9E9E9E', 's': '#607D8B', 't': '#3949AB',
      'u': '#D32F2F', 'v': '#C2185B', 'w': '#7B1FA2', 'x': '#512DA8',
      'y': '#303F9F', 'z': '#1976D2'
    },
    
    // Lighter background colors that need dark text
    needsDarkText: ['l', 'm', 'n'],
    
    init: function() {
      // Use a unique namespace for this search page functionality
      if (window.searchProfilePlaceholdersInitialized) return;
      window.searchProfilePlaceholdersInitialized = true;
      
      // Initial processing with delay to ensure DOM is fully loaded
      setTimeout(() => {
        this.processSearchPageImages();
      }, 500);
      
      // Set up observer for dynamically added content
      this.setupSearchObserver();
    },
    
    processSearchPageImages: function() {
      // Process all profile pictures in the search container
      document.querySelectorAll('.chat-container .profile-pic').forEach(img => {
        this.processProfileImage(img);
      });
    },
    
    processProfileImage: function(imgElement) {
      // Use a different data attribute to avoid conflicts
      if (imgElement.dataset.searchPlaceholderApplied === 'true') return;
      
      // Mark as processed with our unique attribute
      imgElement.dataset.searchPlaceholderApplied = 'true';
      
      // Get image source
      const imgSrc = imgElement.getAttribute('src');
      
      // Check if it's a default, placeholder or error profile image
      const isDefaultImage = !imgSrc || 
                             imgSrc.includes('default_profile') || 
                             imgSrc.includes('placeholder') ||
                             imgSrc === '' || 
                             imgSrc === 'undefined';
      
      if (isDefaultImage) {
        const name = this.getNameFromContext(imgElement);
        if (name) {
          this.createProfilePlaceholder(imgElement, name);
        }
      }
      
      // Also handle image error cases
      imgElement.onerror = () => {
        const name = this.getNameFromContext(imgElement);
        if (name) {
          this.createProfilePlaceholder(imgElement, name);
          // Prevent infinite error loop
          imgElement.onerror = null;
        }
      };
    },
    
    getNameFromContext: function(imgElement) {
      let name = '';
      
      // Try to extract name from username element
      const messageElement = imgElement.closest('.message');
      if (messageElement) {
        const usernameElement = messageElement.querySelector('.username');
        if (usernameElement && usernameElement.textContent) {
          name = usernameElement.textContent.trim();
        }
      }
      
      // Fallback to alt attribute
      if (!name && imgElement.alt) {
        name = imgElement.alt;
      }
      
      return name || 'User';
    },
    
    createProfilePlaceholder: function(imgElement, name) {
      // Get first letter (normalized to lowercase for color mapping)
      const firstLetter = name.trim().charAt(0).toLowerCase();
      
      // Get background color based on first letter
      const backgroundColor = this.letterColors[firstLetter] || '#607D8B';
      
      // Determine text color (white or dark gray)
      const textColor = this.needsDarkText.includes(firstLetter) ? '#202124' : '#FFFFFF';
      
      // Create canvas element
      const canvas = document.createElement('canvas');
      const size = Math.max(imgElement.width || 40, imgElement.height || 40, 40);
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // Draw circular background
      ctx.fillStyle = backgroundColor;
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw letter
      ctx.fillStyle = textColor;
      ctx.font = `bold ${size * 0.45}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(name.charAt(0).toUpperCase(), size/2, size/2);
      
      // Replace image source with canvas data URL
      imgElement.src = canvas.toDataURL('image/png');
    },
    
    setupSearchObserver: function() {
      // Create mutation observer specific for search page
      const searchObserver = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          // Check for new nodes
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(node => {
              // Check if node is an element
              if (node.nodeType === 1) {
                // Check for profile pictures inside the added node
                const profileImages = node.querySelectorAll('.profile-pic');
                if (profileImages.length > 0) {
                  profileImages.forEach(img => this.processProfileImage(img));
                }
                
                // If the node itself is a profile picture
                if (node.classList && node.classList.contains('profile-pic')) {
                  this.processProfileImage(node);
                }
              }
            });
          }
          
          // Check for attribute changes that might indicate new src
          if (mutation.type === 'attributes' && 
              mutation.attributeName === 'src' && 
              mutation.target.classList && 
              mutation.target.classList.contains('profile-pic')) {
            this.processProfileImage(mutation.target);
          }
        });
      });
      
      // Start observing the chat container
      const chatContainer = document.getElementById('chat-container');
      if (chatContainer) {
        searchObserver.observe(chatContainer, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['src']
        });
      }
    }
  };
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      SearchProfilePlaceholderGenerator.init();
    });
  } else {
    // If DOM is already loaded, initialize with delay
    setTimeout(() => {
      SearchProfilePlaceholderGenerator.init();
    }, 100);
  }
})();


  </script>

</body>
</html>

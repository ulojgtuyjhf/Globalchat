
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitter-Style Screen Divider</title>
    <style>
    
/* Global Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Smooth Scrolling */
html {
    scroll-behavior: smooth;
}

/* Prevent scrolling on the main container */
html, body {
    overflow: hidden;
    height: 100%;
    width: 100%;
}

body {
    display: flex;
    flex-direction: column;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: #f9f9f9;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    color: #333;
}

/* Mobile Menu */
.mobile-menu {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 53px;
    background: #ffffff;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    border-bottom: 1px solid #e0e7ff;
    transition: transform 0.3s ease;
}

/* Class for hiding menu */
.mobile-menu.hidden {
    transform: translateY(-100%);
}

.menu-items {
    display: flex;
    justify-content: space-around;
    align-items: center;
    height: 100%;
    padding: 0 15px;
}

.menu-item {
    position: relative;
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 50%;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: pointer;
}

.menu-item svg {
    width: 24px;
    height: 24px;
    fill: none;
    stroke: #666;
    stroke-width: 2;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.menu-item.active {
    background: transparent;
}

.menu-item.active svg {
    stroke: #1da1f2; /* Twitter blue */
    fill: none;
}

.menu-item:hover {
    background-color: rgba(29, 161, 242, 0.1); /* Twitter blue with opacity */
}

.menu-item::after {
    content: '';
    position: absolute;
    bottom: 0px;
    left: 50%;
    width: 0;
    height: 4px;
    background: #1da1f2; /* Twitter blue */
    transform: translateX(-50%);
    transition: width 0.2s ease;
    border-radius: 9999px;
}

.menu-item.active::after {
    width: 20px;
}

/* Main Content Sections */
.content-wrapper {
    display: flex;
    flex: 1;
    margin-top: 0;
    width: 100%;
    height: 100%;
    position: relative;
    transition: margin-top 0.3s ease, height 0.3s ease;
}

.section {
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
    transition: all 0.3s ease;
    height: 100%;
    border-right: 1px solid #e0e7ff;
}

.left-section, .right-section {
    width: 25%;
    background: #ffffff;
}

.middle-section {
    width: 50%;
    background: #ffffff;
}

iframe {
    width: 100%;
    height: 100%;
    border: none;
    border-radius: 0;
    display: block;
    background: #ffffff;
}

/* Updated Twitter-style loading spinner */
.loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    justify-content: center;
    align-items: center;
}

.twitter-spinner {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 3px solid rgba(29, 161, 242, 0.2);
    border-top-color: #1da1f2;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

/* Error message styling */
.error-container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    height: 100%;
    width: 100%;
}

.error-icon {
    font-size: 48px;
    color: #1da1f2;
    margin-bottom: 16px;
}

.error-message {
    font-size: 16px;
    color: #333;
    margin-bottom: 16px;
}

.retry-button {
    background-color: #1da1f2;
    color: white;
    border: none;
    border-radius: 50px;
    padding: 8px 20px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s;
}

.retry-button:hover {
    background-color: #0c8cd9;
}

/* Responsive Design - Improved */
@media (max-width: 1024px) {
    .left-section, .right-section {
        width: 30%;
    }
    
    .middle-section {
        width: 40%;
    }
}

@media (max-width: 768px) {
    .mobile-menu {
        display: block;
    }

    .content-wrapper {
        margin-top: 53px;
        height: calc(100% - 53px);
    }
    
    /* Adjust content when menu is hidden */
    .content-wrapper.full-height {
        margin-top: 0;
        height: 100%;
    }

    /* For horizontal swiping on mobile */
    .content-wrapper {
        display: flex;
        overflow-x: auto;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE/Edge */
    }
    
    .content-wrapper::-webkit-scrollbar {
        display: none; /* Chrome/Safari/Opera */
    }

    .section {
        flex: 0 0 100%;
        scroll-snap-align: center;
        width: 100% !important;
        border-right: none;
    }
}

@media (max-width: 480px) {
    .menu-item {
        width: 40px;
        height: 40px;
    }
    
    .menu-item svg {
        width: 20px;
        height: 20px;
    }
    
    .error-message {
        font-size: 14px;
    }
}

/* Support for dark mode */
@media (prefers-color-scheme: dark) {
    body {
        background: #15202b;
        color: #fff;
    }
    
    .mobile-menu, .section, iframe {
        background: #15202b;
    }
    
    .mobile-menu, .section {
        border-color: #38444d;
    }
    
    .error-message {
        color: #fff;
    }
    
    .twitter-spinner::after {
        background: #15202b;
    }
}

    </style>
</head>
<body>
    <!-- Mobile Menu -->
    <div class="mobile-menu" id="mobileMenu">
        <div class="menu-items">
            <div class="menu-item active" data-section="home">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                  <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
            </div>
            <div class="menu-item" data-section="explore">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-width="1.2">
  <circle cx="12" cy="12" r="10" stroke="currentColor" />
  <path d="M16.5 7.5l-6.2 2.8c-0.15 0.07-0.27 0.19-0.34 0.34L7.5 16.5c-0.26 0.56 0.32 1.14 0.88 0.88l6.2-2.8c0.15-0.07 0.27-0.19 0.34-0.34l2.8-6.2c0.26-0.56-0.32-1.14-0.88-0.88z" fill="currentColor" />
  <circle cx="12" cy="12" r="0.8" fill="white" stroke="none" />
</svg>
            </div>
            <div class="menu-item" data-section="profile">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="content-wrapper" id="contentWrapper">
        <div class="middle-section section active" id="homeSection">
            <div class="loading-indicator">
                <div class="twitter-spinner"></div>
            </div>
        </div>
        <div class="left-section section" id="exploreSection">
            <div class="loading-indicator">
                <div class="twitter-spinner"></div>
            </div>
        </div>
        <div class="right-section section" id="profileSection">
            <div class="loading-indicator">
                <div class="twitter-spinner"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuration for sections and their content
        const sectionConfig = {
            'homeSection': {
                url: './globalchat.html',
                menuId: 'home'
            },
            'exploreSection': {
                url: './fed.html',
                menuId: 'explore'
            },
            'profileSection': {
                url: './profileview.html',
                menuId: 'profile'
            }
        };

        // Global state for scroll management
        window.scrollState = {
            lastScrollY: 0,
            lastScrollTime: Date.now(),
            scrollDirection: null,
            isMenuVisible: true,
            scrollThreshold: 10, // Minimum scroll distance to trigger action
            scrollTimeThreshold: 50, // Time in ms to consider a scroll event relevant
            menuTimer: null,
            menuAutoHideDelay: 3000, // Auto-hide after 3 seconds of inactivity
            disableScrollHandlingTimeout: null
        };

        // Function to load iframe with improved error handling
        function loadIframe(sectionId, url, maxRetries = 5) {
            const section = document.getElementById(sectionId);
            if (!section) {
                console.error(`Section ${sectionId} not found`);
                return;
            }
            
            const loadingIndicator = section.querySelector('.loading-indicator');
            let retryCount = 0;
            let loadTimeout = null;

            // Create a unique loading ID to track this specific load attempt
            const loadId = `load_${sectionId}_${Date.now()}`;
            section.setAttribute('data-loading-id', loadId);

            const loadContent = () => {
                // Clear any existing timeout
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                }
                
                // Only proceed if this is still the current load attempt
                if (section.getAttribute('data-loading-id') !== loadId) return;
                
                // Show loading indicator
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'flex';
                }
                
                const iframe = document.createElement('iframe');
                
                // Add cache busting to ensure fresh content
                const cacheBustUrl = `${url}${url.includes('?') ? '&' : '?'}_cb=${Date.now()}`;
                iframe.src = cacheBustUrl;

                // Set timeout for loading - Twitter-like experience
                loadTimeout = setTimeout(() => {
                    // If still loading after timeout, consider it an error
                    if (section.getAttribute('data-loading-id') === loadId) {
                        retryLoad('Timeout');
                    }
                }, 15000); // 15 second timeout

                iframe.onload = () => {
                    clearTimeout(loadTimeout);
                    
                    // Only update if this is still the current load attempt
                    if (section.getAttribute('data-loading-id') !== loadId) return;
                    
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                    
                    // Set up message listener for communication with iframe content
                    setupIframeMessageListener(iframe);
                    
                    // Verify content loaded correctly
                    try {
                        // This will throw an error for cross-origin iframes
                        const hasContent = iframe.contentDocument && 
                                           iframe.contentDocument.body;
                        
                        // For same-origin iframes, we can check content
                        if (!hasContent) {
                            throw new Error('Empty content');
                        }
                        
                        // Inject scroll listener into the iframe
                        injectScrollListenerIntoIframe(iframe);
                    } catch (e) {
                        // For cross-origin restrictions, we'll assume successful load
                        // This is expected behavior for many embedded contents
                        console.log(`${sectionId} loaded (${e.message || 'cross-origin'})`);
                    }
                };

                iframe.onerror = () => {
                    clearTimeout(loadTimeout);
                    retryLoad('Load error');
                };

                // Clear existing content except loading indicator
                const currentContents = Array.from(section.children);
                currentContents.forEach(element => {
                    if (!element.classList.contains('loading-indicator')) {
                        section.removeChild(element);
                    }
                });
                
                // Add the iframe
                section.appendChild(iframe);
            };

            const retryLoad = (reason) => {
                // Clear any existing timeout
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                }
                
                // Only retry if this is still the current load attempt
                if (section.getAttribute('data-loading-id') !== loadId) return;
                
                console.log(`Retrying ${sectionId} (${retryCount + 1}/${maxRetries}): ${reason}`);
                
                retryCount++;
                if (retryCount <= maxRetries) {
                    // Exponential backoff for retries
                    const delay = Math.min(1000 * Math.pow(1.5, retryCount - 1), 8000);
                    setTimeout(loadContent, delay);
                } else {
                    displayError();
                }
            };

            const displayError = () => {
                // Only display error if this is still the current load attempt
                if (section.getAttribute('data-loading-id') !== loadId) return;
                
                // Hide loading indicator
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                
                // Remove all content except loading indicator
                const currentContents = Array.from(section.children);
                currentContents.forEach(element => {
                    if (!element.classList.contains('loading-indicator')) {
                        section.removeChild(element);
                    }
                });
                
                // Create Twitter-style error message
                const errorContainer = document.createElement('div');
                errorContainer.className = 'error-container';
                errorContainer.innerHTML = `
                    <div class="error-icon">⚠️</div>
                    <div class="error-message">Hmm...something went wrong. Please try again.</div>
                    <button class="retry-button" id="retry-${sectionId}">Retry</button>
                `;
                
                section.appendChild(errorContainer);
                
                // Add retry button handler
                document.getElementById(`retry-${sectionId}`).addEventListener('click', () => {
                    retryCount = 0;
                    loadContent();
                });
            };

            loadContent();
        }

        // Function to set up message listener for communication with iframe content
        function setupIframeMessageListener(iframe) {
            window.addEventListener('message', (event) => {
                // Verify origin if needed for security
                // if (event.origin !== "http://your-trusted-domain.com") return;
                
                if (event.data && event.data.type === 'scroll') {
                    handleScrollFromIframe(event.data);
                }
            });
        }

        // Function to inject scroll listener script into iframe (for same-origin iframes)
        function injectScrollListenerIntoIframe(iframe) {
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                if (!iframeDoc) return;
                
                // Create script element
                const script = iframeDoc.createElement('script');
                script.textContent = `
                    // Scroll detection variables
                    let lastScrollY = 0;
                    let lastScrollTime = Date.now();
                    let scrollTimeout = null;
                    let ticking = false;
                    
                    // Throttle function for better performance
                    function throttle(callback, limit) {
                        if (!ticking) {
                            ticking = true;
                            setTimeout(() => {
                                callback();
                                ticking = false;
                            }, limit);
                        }
                    }
                    
                    // Function to track scroll and send to parent
                    function trackScroll() {
                        const currentScrollY = window.scrollY || document.documentElement.scrollTop;
                        const currentTime = Date.now();
                        const deltaY = currentScrollY - lastScrollY;
                        
                        // Only register significant scrolls
                        if (Math.abs(deltaY) > 5) {
                            // Send message to parent window
                            window.parent.postMessage({
                                type: 'scroll',
                                scrollY: currentScrollY,
                                deltaY: deltaY,
                                timestamp: currentTime
                            }, '*');
                            
                            lastScrollY = currentScrollY;
                            lastScrollTime = currentTime;
                        }
                    }
                    
                    // Add scroll event listener using throttle for better performance
                    window.addEventListener('scroll', () => {
                        throttle(trackScroll, 50);
                    }, { passive: true });
                    
                    // Also track touch events for more responsive mobile experience
                    let touchStartY = 0;
                    
                    window.addEventListener('touchstart', (e) => {
                        touchStartY = e.touches[0].clientY;
                    }, { passive: true });
                    
                    window.addEventListener('touchmove', (e) => {
                        const currentTouchY = e.touches[0].clientY;
                        const deltaY = touchStartY - currentTouchY;
                        
                        // Send touch move as scroll event
                        if (Math.abs(deltaY) > 10) {
                            window.parent.postMessage({
                                type: 'scroll',
                                deltaY: deltaY,
                                timestamp: Date.now(),
                                isTouchMove: true
                            }, '*');
                            
                            // Update for next move
                            touchStartY = currentTouchY;
                        }
                    }, { passive: true });
                    
                    // Send initial ready message to parent
                    window.parent.postMessage({
                        type: 'iframe-ready'
                    }, '*');
                `;
                
                // Append to body or head
                if (iframeDoc.body) {
                    iframeDoc.body.appendChild(script);
                } else if (iframeDoc.head) {
                    iframeDoc.head.appendChild(script);
                }
            } catch (e) {
                // Error accessing iframe content - likely cross-origin restrictions
                console.log('Cannot inject scroll listener into iframe due to cross-origin policy');
            }
        }

        // Function to handle scroll events from iframes
        function handleScrollFromIframe(data) {
            const { deltaY, timestamp, isTouchMove } = data;
            
            // If scroll handling is temporarily disabled, ignore
            if (window.scrollState.disableScrollHandlingTimeout) return;
            
            const currentTime = Date.now();
            const timeSinceLastScroll = currentTime - window.scrollState.lastScrollTime;
            
            // Only register if enough time has passed since last scroll
            if (timeSinceLastScroll > window.scrollState.scrollTimeThreshold) {
                // Determine scroll direction
                const direction = deltaY > 0 ? 'down' : 'up';
                
                // Update scroll state
                window.scrollState.lastScrollTime = currentTime;
                window.scrollState.scrollDirection = direction;
                
                // Handle menu visibility based on scroll direction
                if (window.innerWidth <= 768) {  // Only on mobile
                    if (direction === 'down' && window.scrollState.isMenuVisible) {
                        hideMenu();
                    } else if (direction === 'up' && !window.scrollState.isMenuVisible) {
                        showMenu();
                    }
                }
                
                // Reset auto-hide timer
                resetMenuTimer();
            }
        }
        
        // Function to show the menu
        function showMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            const contentWrapper = document.getElementById('contentWrapper');
            
            if (mobileMenu && contentWrapper) {
                mobileMenu.classList.remove('hidden');
                contentWrapper.classList.remove('full-height');
                window.scrollState.isMenuVisible = true;
                
                // Temporarily disable scroll handling to prevent flicker
                window.scrollState.disableScrollHandlingTimeout = setTimeout(() => {
                    window.scrollState.disableScrollHandlingTimeout = null;
                }, 500);
            }
        }
        
        // Function to hide the menu
        function hideMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            const contentWrapper = document.getElementById('contentWrapper');
            
            if (mobileMenu && contentWrapper) {
                mobileMenu.classList.add('hidden');
                contentWrapper.classList.add('full-height');
                window.scrollState.isMenuVisible = false;
                
                // Temporarily disable scroll handling to prevent flicker
                window.scrollState.disableScrollHandlingTimeout = setTimeout(() => {
                    window.scrollState.disableScrollHandlingTimeout = null;
                }, 500);
            }
        }
        
        // Function to reset menu auto-hide timer
        function resetMenuTimer() {
            if (window.scrollState.menuTimer) {
                clearTimeout(window.scrollState.menuTimer);
            }
            
            // Auto-hide menu after delay (only on mobile)
            if (window.innerWidth <= 768) {
                window.scrollState.menuTimer = setTimeout(() => {
                    if (window.scrollState.isMenuVisible) {
                        hideMenu();
                    }
                }, window.scrollState.menuAutoHideDelay);
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', () => {
            const mobileMenu = document.getElementById('mobileMenu');
            const contentWrapper = document.getElementById('contentWrapper');
            const menuItems = document.querySelectorAll('.menu-item');
            
            // Initialize menu state
            window.scrollState.isMenuVisible = true;
            
            // Load initial content for all sections
            Object.entries(sectionConfig).forEach(([sectionId, config]) => {
                loadIframe(sectionId, config.url, 10);
            });
            
            // Function to update interaction time and show menu
            const updateInteractionTime = () => {
                // Show menu if it was hidden
                if (!window.scrollState.isMenuVisible) {
                    showMenu();
                }
                
                // Reset the timer
                resetMenuTimer();
            };
            
            // Function to activate a section
            const activateSection = (sectionType) => {
                // Find section ID from menu ID
                let targetSectionId = null;
                Object.entries(sectionConfig).forEach(([sectionId, config]) => {
                    if (config.menuId === sectionType) {
                        targetSectionId = sectionId;
                    }
                });
                
                if (!targetSectionId) return;
                
                // Get target section
                const targetSection = document.getElementById(targetSectionId);
                if (!targetSection) return;
                
                // Update menu highlighting
                menuItems.forEach(item => {
                    if (item.getAttribute('data-section') === sectionType) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                // Scroll to section (smooth on desktop, instant on mobile for better feel)
                const behavior = window.innerWidth <= 768 ? 'smooth' : 'auto';
                targetSection.scrollIntoView({ behavior, block: 'nearest', inline: 'start' });
                
                // Ensure content is loaded
                const iframe = targetSection.querySelector('iframe');
                if (!iframe || !iframe.contentWindow) {
                    loadIframe(targetSectionId, sectionConfig[targetSectionId].url, 10);
                }
            };
            
            // Mobile menu item click handlers
            menuItems.forEach(item => {
                item.addEventListener('click', () => {
                    const sectionType = item.getAttribute('data-section');
                    activateSection(sectionType);
                    updateInteractionTime();
                });
            });
            
            // Start the menu auto-hide timer
            resetMenuTimer();
            
            // Track user interactions to reset the timer
            document.addEventListener('touchstart', updateInteractionTime);
            document.addEventListener('click', updateInteractionTime);
            
            // For detecting horizontal swipes
            let touchStartX = 0;
            let touchEndX = 0;
            let touchStartY = 0;
            let touchEndY = 0;
            let isSwiping = false;
            
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                isSwiping = true;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                if (!isSwiping) return;
                
                // Determine direction while swiping
                const currentX = e.touches[0].clientX;
                const diffX = touchStartX - currentX;
                
                // If significant horizontal movement, prevent default to avoid page scrolling
                if (Math.abs(diffX) > 10) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                if (!isSwiping) return;
                
                touchEndX = e.changedTouches[0].clientX;
                touchEndY = e.changedTouches[0].clientY;
                
                // Calculate swipe distance and direction
                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;
                
                // Only handle horizontal swipes (ignore vertical swipes)
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                    handleSwipe(diffX);
                }
                
                // Detect swipe from bottom edge to show menu
                if (Math.abs(diffY) > 50 && touchStartY > window.innerHeight - 100 && diffY < 0) {
                    showMenu();
                }
                
                isSwiping = false;
                updateInteractionTime();
            }, { passive: true });
            
            // Handle swipe direction
            const handleSwipe = (diffX) => {
                // Get current visible section
                const visibleSectionId = getCurrentVisibleSection();
                if (!visibleSectionId) return;
                
                // Get section order
                const sectionOrder = ['homeSection', 'exploreSection', 'profileSection'];
                const currentIndex = sectionOrder.indexOf(visibleSectionId);
                
                if (currentIndex === -1) return;
                
                let targetIndex;
                if (diffX > 0) {
                    // Swipe left - go to next section
                    targetIndex = Math.min(sectionOrder.length - 1, currentIndex + 1);
                } else {
                    // Swipe right - go to previous section
                    targetIndex = Math.max(0, currentIndex - 1);
                }
                
                if (targetIndex !== currentIndex) {
                    const targetSectionId = sectionOrder[targetIndex];
                    const targetSection = document.getElementById(targetSectionId);
                    if (targetSection) {
                        // Find menu ID for this section
                        const menuId = sectionConfig[targetSectionId].menuId;
                        activateSection(menuId);
                    }
                }
            };
            
            // Function to determine which section is currently visible
            const getCurrentVisibleSection = () => {
                if (window.innerWidth <= 768) {
                    // On mobile, use scroll position
                    const scrollLeft = contentWrapper.scrollLeft;
                    const containerWidth = contentWrapper.clientWidth;
                    
                    // Calculate which section is most visible
                    const sectionOrder = ['homeSection', 'exploreSection', 'profileSection'];
                    const visibleIndex = Math.round(scrollLeft / containerWidth);
                    
                    return sectionOrder[visibleIndex] || sectionOrder[0];
                } else {
                    // On desktop, just return the first section
                    return 'homeSection';
                }
            };
            
            // Update menu based on scroll position (for swipe navigation)
            contentWrapper.addEventListener('scroll', () => {
                if (window.innerWidth <= 768) {
                    // Debounce scroll events
                    clearTimeout(contentWrapper.scrollTimer);
                    contentWrapper.scrollTimer = setTimeout(() => {
                        const currentSectionId = getCurrentVisibleSection();
                        if (currentSectionId && sectionConfig[currentSectionId]) {
                            const menuId = sectionConfig[currentSectionId].menuId;
                            
                            // Update menu UI without scrolling
                            menuItems.forEach(item => {
                                if (item.getAttribute('data-section') === menuId) {
                                    item.classList.add('active');
                                } else {
                                    item.classList.remove('active');
                                }
                            });
                        }
                        
                        updateInteractionTime();
                    }, 100);
                }
            }, { passive: true });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                // Recalculate layout for responsive design
                if (window.innerWidth <= 768) {
                    // On mobile, make sure the current section is properly scrolled into view
                    const currentSectionId = getCurrentVisibleSection();
                    if (currentSectionId) {
                        const section = document.getElementById(currentSectionId);
                        if (section) {
                            section.scrollIntoView({ behavior: 'auto' });
                        }
                    }
                }
            });
            
            
            // Periodically check for broken iframes and reload if needed
            setInterval(() => {
                Object.entries(sectionConfig).forEach(([sectionId, config]) => {
                    const section = document.getElementById(sectionId);
                    if (!section) return;
                    
                    const iframe = section.querySelector('iframe');
                    
                    // Check if iframe is missing or broken
                    let needsReload = false;
                    
                    if (!iframe) {
                        needsReload = true;
                    } else {
                        try {
                            // Try to access iframe properties - will fail if broken
                            if (!iframe.contentWindow || iframe.contentWindow.document === null) {
                                needsReload = true;
                            }
                        } catch (e) {
                            // Cross-origin restrictions will cause error - that's normal
                            // We only reload if we can detect it's actually broken
                            if (e.name !== 'SecurityError') {
                                needsReload = true;
                            }
                        }
                    }
                    
                    if (needsReload) {
                        console.log(`Reloading broken iframe in ${sectionId}`);
                        loadIframe(sectionId, config.url, 10);
                    }
                });
            }, 60000); // Check every minute
        });
        
        // Add global methods for iframe communication
        window.parentInterface = {
            notifyScroll: function(deltaY) {
                handleScrollFromIframe({
                    deltaY: deltaY, 
                    timestamp: Date.now()
                });
            },
            showMenu: function() {
                showMenu();
                resetMenuTimer();
            },
            hideMenu: function() {
                hideMenu();
            }
        };
        
        // Swipe detection variables
        let touchStartY = 0;
        
        // Add event listener for swipe up from bottom of screen
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        document.addEventListener('touchend', (e) => {
            const touchEndY = e.changedTouches[0].clientY;
            const diffY = touchStartY - touchEndY;
            
            // If swiping up from bottom of screen
            if (diffY < -70 && touchStartY > window.innerHeight - 100) {
                showMenu();
                resetMenuTimer();
            }
        }, { passive: true });
        
        // Add global scroll handler for the main document
        document.addEventListener('scroll', (e) => {
            const currentScrollY = window.scrollY || document.documentElement.scrollTop;
            const deltaY = currentScrollY - window.scrollState.lastScrollY;
            
            // Only register significant scrolls
            if (Math.abs(deltaY) > window.scrollState.scrollThreshold) {
                const direction = deltaY > 0 ? 'down' : 'up';
                window.scrollState.scrollDirection = direction;
                window.scrollState.lastScrollY = currentScrollY;
                window.scrollState.lastScrollTime = Date.now();
                
                // Handle menu visibility based on scroll direction
                if (window.innerWidth <= 768) {  // Only on mobile
                    if (direction === 'down' && window.scrollState.isMenuVisible) {
                        hideMenu();
                    } else if (direction === 'up' && !window.scrollState.isMenuVisible) {
                        showMenu();
                    }
                }
                
                // Reset auto-hide timer
                resetMenuTimer();
            }
        }, { passive: true });
    </script>
    <script src="theme.js"></script>
    <script>
  document.addEventListener("DOMContentLoaded", function() {
    // Completely disable beforeunload (prevents leave warnings)
    window.addEventListener("beforeunload", function(event) {
      event.stopImmediatePropagation();
    });
    
    // Block all key-based refreshes
    document.addEventListener("keydown", function(event) {
      if (event.key === "F5" || (event.ctrlKey && event.key === "r")) {
        event.preventDefault();
        console.log("🔒 Page refresh blocked.");
      }
    });
    
    // Block resize-based refresh (keyboard opening)
    let lastHeight = window.innerHeight;
    window.addEventListener("resize", function(event) {
      if (window.innerHeight < lastHeight) {
        event.stopImmediatePropagation();
        console.log("🔒 Resize refresh blocked.");
      }
      lastHeight = window.innerHeight;
    });
    
    // Prevent iframe-based refresh
    let iframes = document.querySelectorAll("iframe");
    iframes.forEach(iframe => {
      iframe.addEventListener("load", function() {
        iframe.contentWindow.addEventListener("beforeunload", function(event) {
          event.stopImmediatePropagation();
        });
      });
    });
    
    // Block navigation changes
    history.pushState(null, null, document.URL);
    window.addEventListener("popstate", function(event) {
      history.pushState(null, null, document.URL);
    });
    
    console.log("🚨 Absolute refresh prevention activated. No warnings, no popups, no reloads.");
  });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Essential Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- Primary Meta Tags -->
    <title>Global Chat Room | Connect with People Worldwide | Nmedea.com</title>
    
    
    
    
    <!-- Fonts -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" as="style">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap">
    
   <link rel="stylesheet" href="chat.css">
  <link rel="icon" type="image/png" href="https://firebasestorage.googleapis.com/v0/b/chatnot-e5b4e.firebasestorage.app/o/Black%20and%20Blue%20Initials%20Creative%20Logo_20250214_091517_0000.png?alt=media&token=e420af56-8bd5-4691-b246-b0485c30dccd">
</head>
<body>
  <div class="chat-container" id="chatContainer">
    <div class="loading-dots" id="loadingIndicator" style="display: none;">
      <div class="loading-dot"></div>
      <div class="loading-dot"></div>
      <div class="loading-dot"></div>
    </div>
  </div>
  <div class="input-container">
    <textarea id="messageInput" placeholder="Type your message..."></textarea>
    <button onclick="sendMessage()">
      <img src="https://cdn-icons-png.flaticon.com/512/786/786205.png" alt="Send">
    </button>

  </div>
<script type="module" src="chat.js"></script>
<script src="reply.js"></script>
<script src="replyhighl.js"></script>
<script src="link.js"></script>
<script src="check.js"></script>
<script src="loadfollow.js"></script>
<script src="viewprof.js"></script>
<script src="ad.js"></script>
<script src="mark.js"></script>
<script src="sound.js"></script>
<script src="like.js"></script>
<script src="skelechat.js"></script>
<script src="language.js"></script>
<script src="little.js"></script>
<script src="autoscroll.js"></script>
<script src="remove.js"></script>
<script src="highflk.js"></script>
<script src="vtot.js"></script>
<script src="copy.js"></script>
<script src="backprof.js"></script>
<script src="secchat.js"></script>

<script>
(() => {
  const profileModal = document.querySelector('.profile-modal');
  const content = profileModal.querySelector('.profile-content');
  const profileName = profileModal.querySelector('.profile-name');
  const profileFlag = profileModal.querySelector('.profile-flag');
  const profileImage = profileModal.querySelector('.profile-image');

  // Add full-screen image modal
  const fullScreenImageModal = document.createElement('div');
  fullScreenImageModal.className = 'fullscreen-image-modal';
  fullScreenImageModal.innerHTML = `
    <div class="fullscreen-image-container">
      <img class="fullscreen-image">
    </div>
  `;
  document.body.appendChild(fullScreenImageModal);

  // Enhanced styles for multi-directional dragging
  const imageModalStyles = document.createElement('style');
  imageModalStyles.textContent = `
    .fullscreen-image-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 2000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .fullscreen-image-modal.active {
      display: flex;
      opacity: 1;
    }
    
    .fullscreen-image-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 600px;
      transition: all 0.3s ease;
      cursor: grab;
    }
    
    .fullscreen-image-container.dragging {
      cursor: grabbing;
      transition: none;
    }
    
    .fullscreen-image {
      width: 100%;
      height: auto;
      border-radius: 20px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      pointer-events: none;
    }
    
    .country-tooltip {
      position: absolute;
      background: white;
      padding: 8px 16px;
      border-radius: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transform: translateY(-100%);
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
      white-space: nowrap;
      z-index: 1001;
    }
  `;
  document.head.appendChild(imageModalStyles);

  // Country codes to full names mapping
  const countryNames = {
    'af': 'Afghanistan',
    'al': 'Albania',
    'dz': 'Algeria',
    'ad': 'Andorra',
    'ao': 'Angola',
    'ar': 'Argentina',
    'am': 'Armenia',
    'au': 'Australia',
    'at': 'Austria',
    'az': 'Azerbaijan',
    'bs': 'Bahamas',
    'bh': 'Bahrain',
    'bd': 'Bangladesh',
    'bb': 'Barbados',
    'by': 'Belarus',
    'be': 'Belgium',
    'bz': 'Belize',
    'bj': 'Benin',
    'bt': 'Bhutan',
    'bo': 'Bolivia',
    'br': 'Brazil',
    'bn': 'Brunei',
    'bg': 'Bulgaria',
    'ca': 'Canada',
    'cn': 'China',
    'co': 'Colombia',
    'dk': 'Denmark',
    'eg': 'Egypt',
    'fr': 'France',
    'de': 'Germany',
    'gr': 'Greece',
    'in': 'India',
    'id': 'Indonesia',
    'ir': 'Iran',
    'iq': 'Iraq',
    'ie': 'Ireland',
    'il': 'Israel',
    'it': 'Italy',
    'jp': 'Japan',
    'ke': 'Kenya',
    'kr': 'South Korea',
    'kw': 'Kuwait',
    'my': 'Malaysia',
    'mx': 'Mexico',
    'ma': 'Morocco',
    'np': 'Nepal',
    'nl': 'Netherlands',
    'nz': 'New Zealand',
    'ng': 'Nigeria',
    'no': 'Norway',
    'pk': 'Pakistan',
    'ph': 'Philippines',
    'pl': 'Poland',
    'pt': 'Portugal',
    'qa': 'Qatar',
    'ru': 'Russia',
    'sa': 'Saudi Arabia',
    'sg': 'Singapore',
    'za': 'South Africa',
    'es': 'Spain',
    'lk': 'Sri Lanka',
    'se': 'Sweden',
    'ch': 'Switzerland',
    'tw': 'Taiwan',
    'th': 'Thailand',
    'tr': 'Turkey',
    'ae': 'United Arab Emirates',
    'gb': 'United Kingdom',
    'us': 'United States of America',
    'vn': 'Vietnam',
    'ye': 'Yemen',
    'zm': 'Zambia',
    'zw': 'Zimbabwe'
  };

  // Get full country name from flag src
  const getCountryName = (src) => {
    const code = src.split('/').pop().split('.')[0].toLowerCase();
    return countryNames[code] || code.charAt(0).toUpperCase() + code.slice(1);
  };

  // Enhanced drag handling
  let startX = 0;
  let startY = 0;
  let currentX = 0;
  let currentY = 0;
  let isDragging = false;
  let initialTransform = { x: 0, y: 0 };
  const imageContainer = fullScreenImageModal.querySelector('.fullscreen-image-container');

  const handleDragStart = (e) => {
    const touch = e.touches ? e.touches[0] : e;
    startX = touch.clientX;
    startY = touch.clientY;
    isDragging = true;
    imageContainer.classList.add('dragging');
    
    // Store initial transform values
    const transform = window.getComputedStyle(imageContainer).transform;
    const matrix = new DOMMatrix(transform);
    initialTransform = {
      x: matrix.m41,
      y: matrix.m42
    };
  };

  const handleDragMove = (e) => {
    if (!isDragging) return;
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    currentX = touch.clientX;
    currentY = touch.clientY;
    
    const deltaX = currentX - startX;
    const deltaY = currentY - startY;
    
    // Calculate distance from center for scaling
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const scale = Math.max(0.7, 1 - (distance / window.innerHeight) * 0.3);
    
    // Calculate opacity based on distance
    const opacity = Math.max(0.2, 1 - (distance / window.innerHeight) * 0.8);
    
    imageContainer.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px)) scale(${scale})`;
    fullScreenImageModal.style.background = `rgba(0,0,0,${opacity * 0.95})`;
  };

  const handleDragEnd = () => {
    if (!isDragging) return;
    isDragging = false;
    imageContainer.classList.remove('dragging');
    
    const deltaX = currentX - startX;
    const deltaY = currentY - startY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    imageContainer.style.transition = 'all 0.3s ease';
    
    // Close if dragged far enough
    if (distance > 100) {
      const angle = Math.atan2(deltaY, deltaX);
      const exitX = Math.cos(angle) * window.innerWidth;
      const exitY = Math.sin(angle) * window.innerHeight;
      
      imageContainer.style.transform = `translate(calc(-50% + ${exitX}px), calc(-50% + ${exitY}px)) scale(0.7)`;
      fullScreenImageModal.style.opacity = '0';
      
      setTimeout(() => {
        fullScreenImageModal.classList.remove('active');
        imageContainer.style.transform = 'translate(-50%, -50%) scale(1)';
        fullScreenImageModal.style.opacity = '1';
        fullScreenImageModal.style.background = 'rgba(0,0,0,0.95)';
      }, 300);
    } else {
      // Spring back to center
      imageContainer.style.transform = 'translate(-50%, -50%) scale(1)';
      fullScreenImageModal.style.background = 'rgba(0,0,0,0.95)';
    }
  };

  // Add touch and mouse event listeners
  if ('ontouchstart' in window) {
    imageContainer.addEventListener('touchstart', handleDragStart);
    imageContainer.addEventListener('touchmove', handleDragMove);
    imageContainer.addEventListener('touchend', handleDragEnd);
  } else {
    imageContainer.addEventListener('mousedown', handleDragStart);
    window.addEventListener('mousemove', handleDragMove);
    window.addEventListener('mouseup', handleDragEnd);
  }

  // Flag tooltip handling
  const showFlagTooltip = (flag) => {
    if (!flag.nextElementSibling?.classList.contains('country-tooltip')) {
      const tooltip = document.createElement('div');
      tooltip.className = 'country-tooltip';
      tooltip.textContent = getCountryName(flag.src);
      
      flag.parentElement.style.position = 'relative';
      flag.parentElement.insertBefore(tooltip, flag.nextSibling);
      
      requestAnimationFrame(() => {
        tooltip.style.opacity = '1';
        tooltip.style.transform = 'translateY(-120%)';
      });
    }
  };

  const hideFlagTooltip = (flag) => {
    const tooltip = flag.nextElementSibling;
    if (tooltip?.classList.contains('country-tooltip')) {
      tooltip.style.opacity = '0';
      tooltip.style.transform = 'translateY(-100%)';
      setTimeout(() => tooltip.remove(), 300);
    }
  };

  // Flag interaction events
  if ('ontouchstart' in window) {
    profileFlag.addEventListener('touchstart', (e) => {
      e.preventDefault();
      showFlagTooltip(e.target);
    });
    
    document.addEventListener('touchstart', (e) => {
      if (!e.target.classList.contains('profile-flag')) {
        hideFlagTooltip(profileFlag);
      }
    });
  } else {
    profileFlag.addEventListener('mouseenter', (e) => showFlagTooltip(e.target));
    profileFlag.addEventListener('mouseleave', (e) => hideFlagTooltip(e.target));
  }

  // Profile image click handler
  profileImage.addEventListener('click', () => {
    const fullscreenImg = fullScreenImageModal.querySelector('.fullscreen-image');
    fullscreenImg.src = profileImage.style.backgroundImage.replace(/url\(['"](.+)['"]\)/, '$1');
    fullScreenImageModal.classList.add('active');
  });

  // Tap to close
  fullScreenImageModal.addEventListener('click', (e) => {
    if (e.target === fullScreenImageModal) {
      fullScreenImageModal.classList.remove('active');
    }
  });

  // Center the profile modal content
  content.style.height = '70vh';
  content.style.maxWidth = '600px';
  content.style.margin = '0 auto';
})();
</script>

<script>
  document.addEventListener("DOMContentLoaded", function() {
    // Create toggle switch container
    const toggleContainer = document.createElement("div");
    toggleContainer.style.position = "fixed";
    toggleContainer.style.top = "16px";
    toggleContainer.style.left = "18px";
    toggleContainer.style.display = "flex";
    toggleContainer.style.alignItems = "center";
    toggleContainer.style.cursor = "pointer";
    toggleContainer.style.zIndex = "9999"; // Always on top
    toggleContainer.style.padding = "5px 10px";
    toggleContainer.style.background = "rgba(255, 255, 255, 0.8)";
    toggleContainer.style.borderRadius = "20px";
    toggleContainer.style.boxShadow = "2px 2px 8px rgba(0, 0, 0, 0.2)";
    toggleContainer.style.transition = "all 0.3s ease";

    // Label
    const toggleLabel = document.createElement("span");
    toggleLabel.innerText = "Chat";
    toggleLabel.style.fontSize = "16px";
    toggleLabel.style.fontWeight = "bold";
    toggleLabel.style.marginRight = "10px";

    // Toggle switch
    const toggleSwitch = document.createElement("div");
    toggleSwitch.style.width = "50px";
    toggleSwitch.style.height = "25px";
    toggleSwitch.style.borderRadius = "50px";
    toggleSwitch.style.background = "#ddd";
    toggleSwitch.style.position = "relative";
    toggleSwitch.style.transition = "background 0.3s ease";

    // Toggle knob
    const toggleKnob = document.createElement("div");
    toggleKnob.style.width = "23px";
    toggleKnob.style.height = "23px";
    toggleKnob.style.borderRadius = "50%";
    toggleKnob.style.background = "#ffffff";
    toggleKnob.style.position = "absolute";
    toggleKnob.style.top = "1px";
    toggleKnob.style.left = "1px";
    toggleKnob.style.transition = "left 0.3s ease, background 0.3s ease";
    toggleKnob.style.boxShadow = "2px 2px 5px rgba(0,0,0,0.2)";

    toggleSwitch.appendChild(toggleKnob);
    toggleContainer.appendChild(toggleLabel);
    toggleContainer.appendChild(toggleSwitch);
    document.body.appendChild(toggleContainer);

    // Create iframe once
    const iframe = document.createElement("iframe");
    iframe.src = "search.html";
    iframe.style.position = "fixed";
    iframe.style.top = "0";
    iframe.style.left = "0";
    iframe.style.width = "100vw";
    iframe.style.height = "100vh";
    iframe.style.border = "none";
    iframe.style.zIndex = "998";
    iframe.style.display = "none"; // Initially hidden
    document.body.appendChild(iframe);

    // Save the original content of the body (excluding the toggle and iframe)
    const originalContent = Array.from(document.body.children).filter(
      (child) => child !== toggleContainer && child !== iframe
    );

    let isChatVisible = true;

    toggleSwitch.addEventListener("click", function() {
      if (isChatVisible) {
        // Hide original content
        originalContent.forEach((child) => {
          child.style.display = "none";
        });

        // Show iframe
        iframe.style.display = "block";
        toggleSwitch.style.background = "black";
        toggleKnob.style.left = "26px";
        toggleKnob.style.background = "#fff";
        toggleLabel.innerText = "Media";
      } else {
        // Show original content
        originalContent.forEach((child) => {
          child.style.display = "";
        });

        // Hide iframe
        iframe.style.display = "none";
        toggleSwitch.style.background = "#ddd";
        toggleKnob.style.left = "1px";
        toggleKnob.style.background = "#ffffff";
        toggleLabel.innerText = "Chat";
      }
      isChatVisible = !isChatVisible;
    });
  });
</script>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // 1. Create checkmark styling
    const style = document.createElement("style");
    style.textContent = `
      .forced-check {
        display: inline-block;
        width: 14px;
        height: 14px;
        background: black;
        border-radius: 50%;
        margin-left: 4px;
        position: relative;
        z-index: 1;
      }
      .forced-check::after {
        content: "✓";
        color: white;
        font-size: 9px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) rotate(15deg);
        font-weight: bold;
      }
    `;
    document.head.appendChild(style);

    // 2. Function to add a checkmark in the correct position
    function addCheckmark(h4) {
      if (!h4.querySelector(".forced-check")) {
        const check = document.createElement("span");
        check.className = "forced-check";

        // Insert after the first text node (username)
        const textNode = Array.from(h4.childNodes).find(n => n.nodeType === Node.TEXT_NODE);
        if (textNode) {
          textNode.parentNode.insertBefore(check, textNode.nextSibling);
        } else {
          h4.appendChild(check);
        }
      }
    }

    // 3. MutationObserver with refined targeting
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (
            node.nodeType === 1 && // Ensure it's an element
            node.classList.contains("message") // Only target messages
          ) {
            const h4 = node.querySelector("h4");
            if (h4) addCheckmark(h4);
          }
        });
      });
    });

    // 4. Observe the chat container if it exists
    const chatContainer = document.getElementById("chatContainer");
    if (chatContainer) {
      observer.observe(chatContainer, { childList: true, subtree: true });
    }
  });
</script>


<script>
  document.addEventListener("DOMContentLoaded", function() {
    // Create emoji container
    const emojiContainer = document.createElement("div");
    emojiContainer.style.position = "absolute";
    emojiContainer.style.bottom = "70px"; // Adjusted to fit above input
    emojiContainer.style.left = "50%";
    emojiContainer.style.transform = "translateX(-50%)";
    emojiContainer.style.display = "flex";
    emojiContainer.style.overflowX = "auto"; // Enables horizontal scrolling
    emojiContainer.style.whiteSpace = "nowrap";
    emojiContainer.style.padding = "10px 5px";
    emojiContainer.style.borderRadius = "10px";
    emojiContainer.style.maxWidth = "90%";
    emojiContainer.style.background = "transparent"; // Removes visible background
    emojiContainer.style.boxShadow = "none";
    emojiContainer.style.zIndex = "9999";
    emojiContainer.style.scrollBehavior = "smooth";
    emojiContainer.style.transition = "opacity 0.3s ease-in-out";
    emojiContainer.style.opacity = "0"; // Hidden by default
    
    // Emojis array
    const emojis = ["😀", "😂", "😍", "🔥", "🚀", "💡", "🎉", "👍", "❤️", "🌍"];
    
    // Append emojis to container with typing animation
    emojis.forEach((emoji, index) => {
      const emojiSpan = document.createElement("span");
      emojiSpan.innerText = emoji;
      emojiSpan.style.fontSize = "22px";
      emojiSpan.style.margin = "0 8px";
      emojiSpan.style.cursor = "pointer";
      emojiSpan.style.transition = "transform 0.2s ease, opacity 0.4s ease-in-out";
      emojiSpan.style.opacity = "0"; // Hidden before animation
      emojiSpan.style.textShadow = "2px 2px 5px rgba(0, 0, 0, 0.3), 0 0 10px rgba(255, 255, 255, 0.8)"; // 3D shiny effect
      emojiSpan.style.transform = "translateY(10px) scale(0.8)";
      emojiSpan.style.filter = "drop-shadow(0 0 5px rgba(255, 255, 255, 0.7))"; // Adds a glowing effect
      
      // Delayed typing animation per emoji
      setTimeout(() => {
        emojiSpan.style.opacity = "1";
        emojiSpan.style.transform = "translateY(0) scale(1)";
      }, index * 100);
      
      // Insert emoji into input field on click
      emojiSpan.addEventListener("click", function() {
        const inputField = document.getElementById("messageInput");
        inputField.value += emoji;
        inputField.focus();
      });
      
      emojiContainer.appendChild(emojiSpan);
    });
    
    // Append emoji container to body
    document.body.appendChild(emojiContainer);
    
    // Show emojis only when the input is focused
    const inputField = document.getElementById("messageInput");
    inputField.addEventListener("focus", () => {
      emojiContainer.style.opacity = "1";
    });
    
    inputField.addEventListener("blur", () => {
      setTimeout(() => {
        emojiContainer.style.opacity = "0"; // Hide after input is blurred
      }, 300);
    });
    
    // Make emojis fully responsive
    emojiContainer.addEventListener("wheel", (event) => {
      event.preventDefault();
      emojiContainer.scrollLeft += event.deltaY; // Horizontal scroll on wheel
    });
    
    // Mobile touch scrolling
    let isDown = false;
    let startX;
    let scrollLeft;
    
    emojiContainer.addEventListener("mousedown", (e) => {
      isDown = true;
      startX = e.pageX - emojiContainer.offsetLeft;
      scrollLeft = emojiContainer.scrollLeft;
    });
    
    emojiContainer.addEventListener("mouseleave", () => {
      isDown = false;
    });
    
    emojiContainer.addEventListener("mouseup", () => {
      isDown = false;
    });
    
    emojiContainer.addEventListener("mousemove", (e) => {
      if (!isDown) return;
      e.preventDefault();
      const x = e.pageX - emojiContainer.offsetLeft;
      const walk = (x - startX) * 2; // Adjust scroll speed
      emojiContainer.scrollLeft = scrollLeft - walk;
    });
    
    emojiContainer.addEventListener("touchstart", (e) => {
      isDown = true;
      startX = e.touches[0].pageX - emojiContainer.offsetLeft;
      scrollLeft = emojiContainer.scrollLeft;
    });
    
    emojiContainer.addEventListener("touchend", () => {
      isDown = false;
    });
    
    emojiContainer.addEventListener("touchmove", (e) => {
      if (!isDown) return;
      const x = e.touches[0].pageX - emojiContainer.offsetLeft;
      const walk = (x - startX) * 2;
      emojiContainer.scrollLeft = scrollLeft - walk;
    });
  });
</script>
<script>
  // Chat content filter with simple 'A' indicator
  const ChatFilter = {
    // Dictionary of words and patterns to filter
   filterPatterns: [
    // Original patterns
    /\b(f+u+c+k+|f+v+c+k+|f+u+k+)\w*/gi,
    /\b(s+h+i+t+)\w*/gi,
    /\b(b+i+t+c+h+)\w*/gi,
    /\b(a+s+s+h+o+l+e+)\w*/gi,
    /\b(d+i+c+k+)\w*/gi,
    /\b(p+u+s+s+y+)\w*/gi,
    /\b(c+u+n+t+)\w*/gi,
    /\b(w+h+o+r+e+)\w*/gi,
    /\b(n+i+g+g+[ea]+r*)\w*/gi,
    /\b(f+a+g+)\w*/gi,
    /\b(r+e+t+a+r+d+)\w*/gi,
    /\b(s+l+u+t+)\w*/gi,
    /\b(k+y+s+)\b/gi,
    /\b(k+i+l+l+\s*y+o+u+r+s+e+l+f+)\b/gi,
    
    // New patterns
    /\b(f[@4]c+k+)\w*/gi, // Leet speak for "fuck"
    /\b(5+h+i+t+)\w*/gi, // Leet speak for "shit"
    /\b(b+i+t+c+h+|b+i+t+c+h+)\w*/gi, // Variants of "bitch"
    /\b(a+s+s+)\w*/gi, // Shortened version of "asshole"
    /\b(d+i+c+k+|d+i+k+)\w*/gi, // Variants of "dick"
    /\b(p+u+s+y+|p+u+z+y+)\w*/gi, // Variants of "pussy"
    /\b(c+u+n+t+|c+u+n+t+)\w*/gi, // Variants of "cunt"
    /\b(w+h+o+r+e+|w+h+o+r+)\w*/gi, // Variants of "whore"
    /\b(n+i+g+[ea]+r+|n+i+g+[ea]+)\w*/gi, // Variants of racial slurs
    /\b(f+a+g+|f+a+g+)\w*/gi, // Variants of "fag"
    /\b(r+e+t+a+r+d+|r+e+t+a+r+d+)\w*/gi, // Variants of "retard"
    /\b(s+l+u+t+|s+l+u+t+)\w*/gi, // Variants of "slut"
    /\b(k+y+s+|k+y+s+)\b/gi, // Variants of "kys"
    /\b(k+i+l+l+\s*y+o+u+r+s+e+l+f+|k+y+s+)\b/gi, // Variants of "kill yourself"
    /\b(f+u+c+k+e+r+|f+u+c+k+e+r+)\w*/gi, // Variants of "fucker"
    /\b(s+h+i+t+h+e+a+d+|s+h+i+t+h+e+a+d+)\w*/gi, // Variants of "shithead"
    /\b(m+o+t+h+e+r+f+u+c+k+e+r+|m+o+t+h+e+r+f+u+c+k+e+r+)\w*/gi, // Variants of "motherfucker"
    /\b(c+o+c+k+|c+o+c+k+)\w*/gi, // Variants of "cock"
    /\b(p+i+s+s+|p+i+s+s+)\w*/gi, // Variants of "piss"
    /\b(b+a+s+t+a+r+d+|b+a+s+t+a+r+d+)\w*/gi, // Variants of "bastard"
    /\b(d+a+m+n+|d+a+m+n+)\w*/gi, // Variants of "damn"
    /\b(h+e+l+l+|h+e+l+l+)\w*/gi, // Variants of "hell"
    /\b(s+c+r+e+w+|s+c+r+e+w+)\w*/gi, // Variants of "screw"
    /\b(f+u+c+k+i+n+g+|f+u+c+k+i+n+g+)\w*/gi, // Variants of "fucking"
    /\b(s+h+i+t+t+y+|s+h+i+t+t+y+)\w*/gi, // Variants of "shitty"
    /\b(a+s+s+w+i+p+e+|a+s+s+w+i+p+e+)\w*/gi, // Variants of "asswipe"
    /\b(b+u+l+l+s+h+i+t+|b+u+l+l+s+h+i+t+)\w*/gi, // Variants of "bullshit"
    /\b(c+r+a+p+|c+r+a+p+)\w*/gi, // Variants of "crap"
    /\b(d+a+m+m+i+t+|d+a+m+m+i+t+)\w*/gi, // Variants of "dammit"
    /\b(f+u+c+k+o+f+f+|f+u+c+k+o+f+f+)\w*/gi, // Variants of "fuckoff"
    /\b(g+o+d+d+a+m+n+|g+o+d+d+a+m+n+)\w*/gi, // Variants of "goddamn"
    /\b(h+o+l+y+s+h+i+t+|h+o+l+y+s+h+i+t+)\w*/gi, // Variants of "holyshit"
    /\b(j+e+r+k+o+f+f+|j+e+r+k+o+f+f+)\w*/gi, // Variants of "jerkoff"
    /\b(p+r+i+c+k+|p+r+i+c+k+)\w*/gi, // Variants of "prick"
    /\b(s+c+r+e+w+y+o+u+|s+c+r+e+w+y+o+u+)\w*/gi, // Variants of "screwyou"
    /\b(s+h+i+t+b+a+g+|s+h+i+t+b+a+g+)\w*/gi, // Variants of "shitbag"
    /\b(s+h+i+t+f+a+c+e+|s+h+i+t+f+a+c+e+)\w*/gi, // Variants of "shitface"
    /\b(s+h+i+t+h+e+a+d+|s+h+i+t+h+e+a+d+)\w*/gi, // Variants of "shithead"
    /\b(s+h+i+t+l+o+a+d+|s+h+i+t+l+o+a+d+)\w*/gi, // Variants of "shitload"
    /\b(s+h+i+t+s+t+a+i+n+|s+h+i+t+s+t+a+i+n+)\w*/gi, // Variants of "shitstain"
    /\b(s+h+i+t+t+y+|s+h+i+t+t+y+)\w*/gi, // Variants of "shitty"
    /\b(s+h+i+t+z+u+|s+h+i+t+z+u+)\w*/gi, // Variants of "shitzu"
],
    
    // Convert text to stars with simple 'A' indicator
    convertToStars(match) {
      return '✱'.repeat(match.length) + '❗';
    },
    
    // Process a single text node
    processTextNode(textNode) {
      let text = textNode.nodeValue;
      let wasFiltered = false;
      
      this.filterPatterns.forEach(pattern => {
        if (pattern.test(text)) {
          text = text.replace(pattern, this.convertToStars);
          wasFiltered = true;
        }
      });
      
      if (wasFiltered) {
        textNode.nodeValue = text;
      }
    },
    
    // Recursively process all text nodes in the chat
    processNode(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        this.processTextNode(node);
      } else {
        Array.from(node.childNodes).forEach(child => this.processNode(child));
      }
    },
    
    // Start monitoring the chat container
    startMonitoring() {
      const chatContainer = document.getElementById('chatContainer');
      
      // Process existing content
      this.processNode(chatContainer);
      
      // Create observer to monitor chat changes
      const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(node => {
              this.processNode(node);
            });
          }
        });
      });
      
      // Start observing chat container
      observer.observe(chatContainer, {
        childList: true,
        subtree: true
      });
    }
  };
  
  // Start the filter when the page loads
  document.addEventListener('DOMContentLoaded', () => {
    ChatFilter.startMonitoring();
  });
</script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    const chatContainer = document.getElementById("chatContainer");
    
    function addSeparators() {
      const messages = document.querySelectorAll(".message");
      
      messages.forEach((message) => {
        // Ensure we don't add duplicate separators
        if (!message.previousElementSibling || !message.previousElementSibling.classList.contains("message-separator")) {
          const separatorBefore = document.createElement("div");
          separatorBefore.classList.add("message-separator");
          message.parentNode.insertBefore(separatorBefore, message);
        }
        
        if (!message.nextElementSibling || !message.nextElementSibling.classList.contains("message-separator")) {
          const separatorAfter = document.createElement("div");
          separatorAfter.classList.add("message-separator");
          message.parentNode.insertBefore(separatorAfter, message.nextSibling);
        }
      });
    }
    
    // Initial setup
    addSeparators();
    
    // Monitor new messages added dynamically
    const observer = new MutationObserver(() => {
      addSeparators();
    });
    
    observer.observe(chatContainer, { childList: true, subtree: true });
    
    // CSS for the separator
    const style = document.createElement("style");
    style.innerHTML = `
        .message-separator {
            height: 1px;
            background: rgba(0, 0, 0, 0.3);
            width: 100%;
            margin: 3px 0; /* Reduced spacing */
        }
    `;
    document.head.appendChild(style);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const messageInput = document.getElementById('messageInput');

    messageInput.addEventListener('keydown', function(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault(); // Prevents a new line in the input
        sendMessage(); // Calls the sendMessage function
      }
    });
  });
</script>